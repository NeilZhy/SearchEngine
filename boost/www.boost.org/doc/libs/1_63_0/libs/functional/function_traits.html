<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
  <meta http-equiv="Content-Language" content="en-us">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <title>Boost Function Object Adapter Library - 1.63.0</title>
<link rel="icon" href="/favicon.ico" type="image/ico"><link rel="stylesheet" type="text/css" href="../../../../../style-v2/section-basic.css" tppabs="https://www.boost.org/style-v2/section-basic.css"><meta name="viewport" content="width=device-width,initial-scale=1.0"/></head>

<body bgcolor="#FFFFFF" text="#000000">  <div id="boost-common-heading-doc">
    <div class="heading-inner">
  <div class="heading-placard"></div>

  <h1 class="heading-title">
  <a href="../../../../../index.htm" tppabs="https://www.boost.org/">
  <img src="../../../../../gfx/space.png" tppabs="https://www.boost.org/gfx/space.png" alt= "Boost C++ Libraries" class="heading-logo" />
  <span class="heading-boost">Boost</span>
  <span class="heading-cpplibraries">C++ Libraries</span>
  </a></h1>

  <p class="heading-quote">
  <q>...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.</q> <span class="heading-attribution">&mdash; <a href=
  "javascript:if(confirm('http://www.gotw.ca/  \n\n该文件无法用 Teleport Ultra 下载, 因为 它是一个域或路径外部被设置为它的启始地址的地址。  \n\n你想在服务器上打开它?'))window.location='http://www.gotw.ca/'" tppabs="http://www.gotw.ca/" class="external">Herb Sutter</a> and <a href=
  "javascript:if(confirm('http://en.wikipedia.org/wiki/Andrei_Alexandrescu  \n\n该文件无法用 Teleport Ultra 下载, 因为 它是一个域或路径外部被设置为它的启始地址的地址。  \n\n你想在服务器上打开它?'))window.location='http://en.wikipedia.org/wiki/Andrei_Alexandrescu'" tppabs="http://en.wikipedia.org/wiki/Andrei_Alexandrescu" class="external">Andrei
  Alexandrescu</a>, <a href=
  "javascript:if(confirm('http://safari.awprofessional.com/?XmlId=0321113586  \n\n该文件无法用 Teleport Ultra 下载, 因为 它是一个域或路径外部被设置为它的启始地址的地址。  \n\n你想在服务器上打开它?'))window.location='http://safari.awprofessional.com/?XmlId=0321113586'" tppabs="http://safari.awprofessional.com/?XmlId=0321113586" class="external">C++
  Coding Standards</a></span></p>
</div>

  </div>

  <div id="boost-common-heading-doc-spacer"></div>
<div class="boost-common-header-notice"><a class="boost-common-header-inner" href="javascript:if(confirm('https://www.boost.org/doc/libs/release/libs/functional/function_traits.html  \n\n该文件无法用 Teleport Ultra 下载, 因为 它是一个与它的启始地址很远的链接。如果你增大启始地址域内深度设置, 该文件将被加入下载队列。  \n\n你想在服务器上打开它?'))window.location='https://www.boost.org/doc/libs/release/libs/functional/function_traits.html'" tppabs="https://www.boost.org/doc/libs/release/libs/functional/function_traits.html">This is the documentation for an old version of Boost.
                Click here to view this page for the latest version.</a></div>

  

  <h1>Function Object Traits</h1>

  <p>The header <a href="javascript:if(confirm('https://www.boost.org/doc/libs/1_56_0/libs/icl/functional.hpp  \n\n该文件无法用 Teleport Ultra 下载, 因为 服务器报告该文件未找到。  \n\n你想在服务器上打开它?'))window.location='https://www.boost.org/doc/libs/1_56_0/libs/icl/functional.hpp'" tppabs="https://www.boost.org/doc/libs/1_63_0/boost/functional.hpp">functional.hpp</a>
  provides two traits class templates for functions and function objects:</p>

  <table border="1" summary="">
    <tr>
      <th>Type</th>

      <th>Contents</th>

      <th>Description</th>
    </tr>

    <tr>
      <td valign="top" rowspan="4">
      <tt>template&nbsp;&lt;typename&nbsp;T&gt;<br>
      struct&nbsp;unary_traits</tt></td>

      <td valign="top"><tt>function_type</tt></td>

      <td valign="top">The type of the function or function object itself
      (i.e., <tt>T</tt>).</td>
    </tr>

    <tr>
      <td valign="top"><tt>param_type</tt></td>

      <td valign="top">The type that should be used to pass the function or
      function object as a parameter.</td>
    </tr>

    <tr>
      <td valign="top"><tt>result_type</tt></td>

      <td valign="top">The type returned by the function or function
      object.</td>
    </tr>

    <tr>
      <td valign="top"><tt>argument_type</tt></td>

      <td valign="top">The type of the argument to the function or function
      object.</td>
    </tr>

    <tr>
      <td valign="top" rowspan="5">
      <tt>template&nbsp;&lt;typename&nbsp;T&gt;<br>
      struct&nbsp;binary_traits</tt></td>

      <td valign="top"><tt>function_type</tt></td>

      <td valign="top">The type of the function or function object itself
      (i.e., <tt>T</tt>).</td>
    </tr>

    <tr>
      <td valign="top"><tt>param_type</tt></td>

      <td valign="top">The type that should be used to pass the function or
      function object as a parameter.</td>
    </tr>

    <tr>
      <td valign="top"><tt>result_type</tt></td>

      <td valign="top">The type returned by the function or function
      object.</td>
    </tr>

    <tr>
      <td valign="top"><tt>first_argument_type</tt></td>

      <td valign="top">The type of the first argument to the function or
      function object.</td>
    </tr>

    <tr>
      <td valign="top"><tt>second_argument_type</tt></td>

      <td valign="top">The type of the second argument to the function or
      function object.</td>
    </tr>
  </table>

  <h3>Usage</h3>

  <p><tt>unary_traits</tt> should be instantiated with either a function
  taking a single parameter, or an adaptable unary function object (i.e., a
  class derived from <tt>std::unary_function</tt> or one which provides the
  same typedefs). (See &sect;20.3.1 in the C++ Standard.)</p>

  <p><tt>binary_traits</tt> should be instantiated with either a function
  taking two parameters, or an adaptable binary function object (i.e., a
  class derived from <tt>std::binary_function</tt> or one which provides the
  same typedefs). (See &sect;20.3.1 in the C++ Standard.)</p>

  <p>The most common usage of these templates is in function object adapters,
  thus allowing them to adapt plain functions as well as function objects.
  You can do this by wherever you would normally write, for example,</p>

  <blockquote>
    <pre>
typename Operation::argument_type
</pre>
  </blockquote>

  <p>simply writing</p>

  <blockquote>
    <pre>
typename boost::unary_traits&lt;Operation&gt;::argument_type
</pre>
  </blockquote>

  <p>instead.</p>

  <h3>Additional Types Defined</h3>

  <p>In addition to the standard result and argument typedefs, these traits
  templates define two additional types.</p>

  <h4><tt>function_type</tt></h4>

  <p>This is the type of the function or function object, and can be used in
  declarations such as</p>

  <blockquote>
    <pre>
template &lt;class Predicate&gt;
class unary_negate : // ...
{
  // ...
  private:
    <strong>typename unary_traits&lt;Predicate&gt;::function_type</strong> pred;
};
</pre>
  </blockquote>

  <p>If this typedef were not provided, it would not be possible to declare
  <tt>pred</tt> in a way that would allow <tt>unary_negate</tt> to be
  instantiated with a function type (see the C++ Standard &sect;14.3.1
  &para;3).</p>

  <h4><tt>param_type</tt></h4>

  <p>This is a type suitable for passing the function or function object as a
  parameter to another function. For example,</p>

  <blockquote>
    <pre>
template &lt;class Predicate&gt;
class unary_negate : // ...
{
  public:
    explicit unary_negate(<strong>typename unary_traits&lt;Predicate&gt;::param_type</strong> x)
        :
        pred(x)
    {}
    // ...
};
</pre>
  </blockquote>

  <p>Function objects are passed by reference to const; function pointers are
  passed by value.</p>

  <h3>Limitations</h3>

  <p>This library uses these traits within all function object adapters,
  theoretically rendering <tt>ptr_fun</tt> obsolete. However, third party
  adapters probably won't take advantage of this mechanism, and so
  <tt>ptr_fun</tt> may still be required. Accordingly, this library also
  provides <a href="ptr_fun.html" tppabs="https://www.boost.org/doc/libs/1_63_0/libs/functional/ptr_fun.html">improved versions of the standard function
  pointer adapters</a>.</p>

  <p>These traits templates will also not work with compilers that fail to
  support partial specialisation of templates. With these compilers, the
  traits templates can only be instantiated with adaptable function objects,
  thus requiring <tt>ptr_fun</tt> to be used, even with the function object
  adapters in this library.</p>
  <hr>

  <p><a href="javascript:if(confirm('http://validator.w3.org/check?uri=referer  \n\n该文件无法用 Teleport Ultra 下载, 因为 它是一个域或路径外部被设置为它的启始地址的地址。  \n\n你想在服务器上打开它?'))window.location='http://validator.w3.org/check?uri=referer'" tppabs="http://validator.w3.org/check?uri=referer"><img border="0" src=
  "../../../1_56_0/libs/integer/valid-html401.png" tppabs="https://www.boost.org/doc/libs/1_63_0/doc/images/valid-html401.png" alt="Valid HTML 4.01 Transitional"
  height="31" width="88"></a></p>

  <p>Revised 
  <!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->02
  December, 2006<!--webbot bot="Timestamp" endspan i-checksum="38510" --></p>

  <p><i>Copyright &copy; 2000 Cadenza New Zealand Ltd.</i></p>

  <p><i>Distributed under the Boost Software License, Version 1.0. (See
  accompanying file <a href="../../LICENSE_1_0.txt.htm" tppabs="https://www.boost.org/doc/libs/1_63_0/LICENSE_1_0.txt">LICENSE_1_0.txt</a> or
  copy at <a href=
  "../../../../../LICENSE_1_0.txt" tppabs="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</i></p>
</body>
</html>
