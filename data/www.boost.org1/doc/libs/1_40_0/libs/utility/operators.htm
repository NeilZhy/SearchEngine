<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
  
    
    
    Header <boost/operators.hpp> Documentation - 1.40.0
  
    
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
This is the documentation for an old version of Boost.
                Click here to view this page for the latest version.
    Header <boost/operators.hpp>
    The header <boost/operators.hpp> supplies
    several sets of class templates (in namespace boost). These
    templates define operators at namespace scope in terms of a minimal
    number of fundamental operators provided by the class.
    Contents
    
      Contents
      
        Rationale 
        
          Summary of Template Semantics
          Use of concepts
        
      
      
        Usage 
        
          
            Two-Argument Template Forms 
            
              General Considerations
              Mixed arithmetics
            
          
          Base Class Chaining and Object
          Size
          Separate, Explicit
          Instantiation
          Requirement Portability
        
      
      Example
      
        Arithmetic operators 
        
          
            Simple Arithmetic Operators 
            
              Ordering Note
              Symmetry Note
            
          
          Grouped Arithmetic Operators
          Example Templates
          Arithmetic Operators Demonstration and Test
          Program
        
      
      
        Dereference Operators and Iterator Helpers 
        
          Dereference operators
          Grouped Iterator Operators
          
            Iterator Helpers 
            
              Iterator Helper
              Notes
            
          
          Iterator Demonstration and Test
          Program
        
      
      Contributors
      Note for Users of Older Versions
    
    Rationale
    Overloaded operators for class types typically occur in groups. If you
    can write x + y, you probably also want to be able
    to write x += y. If you can write x < y, you
    also want x > y, x >= y, and x <= y.
    Moreover, unless your class has really surprising behavior, some of these
    related operators can be defined in terms of others (e.g. x >= y
    <=> !(x < y)). Replicating this boilerplate for multiple
    classes is both tedious and error-prone. The boost/operators.hpp templates help
    by generating operators for you at namespace scope based on other
    operators you've defined in your class.
    If, for example, you declare a class like this:
    
class MyInt
    : boost::operators<MyInt>
{
    bool operator<(const MyInt& x) const;
    bool operator==(const MyInt& x) const;
    MyInt& operator+=(const MyInt& x);
    MyInt& operator-=(const MyInt& x);
    MyInt& operator*=(const MyInt& x);
    MyInt& operator/=(const MyInt& x);
    MyInt& operator%=(const MyInt& x);
    MyInt& operator|=(const MyInt& x);
    MyInt& operator&=(const MyInt& x);
    MyInt& operator^=(const MyInt& x);
    MyInt& operator++();
    MyInt& operator--();
};
    
    then the operators<>
    template adds more than a dozen additional operators, such as
    operator>, <=, >=, and
    (binary) +. Two-argument forms of the
    templates are also provided to allow interaction with other types.
    Summary of Template Semantics
    
      Each operator template completes the concept(s) it describes by
      defining overloaded operators for its target class.
      The name of an operator class template indicates the concept that its target class will model.
      Usually, the target class uses an instantation of the operator
      class template as a base class. Some operator templates support an alternate method.
      The concept can be compound, i.e. it may represent a common
      combination of other, simpler concepts.
      Most operator templates require their target class to support
      operations related to the operators supplied by the template. In
      accordance with widely accepted coding style recommendations, the
      target class is often required to supply the assignment counterpart
      operator of the concept's "main operator." For example, the
      addable template requires operator+=(T
      const&) and in turn supplies operator+(T const&, T
      const&).
    
    Use of concepts
    The discussed concepts are not necessarily the standard library's
    concepts (CopyConstructible, etc.), although some of them could
    be; they are what we call concepts with a small 'c'. In
    particular, they are different from the former ones in that they do
    not describe precise semantics of the operators they require to be
    defined, except the requirements that (a) the semantics of the operators
    grouped in one concept should be consistent (e.g. effects of
    evaluating of a += b and
    a = a + b expressions should be the
    same), and (b) that the return types of the operators should follow
    semantics of return types of corresponding operators for built-in types
    (e.g. operator< should return a type convertible
    to bool, and T::operator-= should return type
    convertible to T). Such "loose" requirements make operators
    library applicable to broader set of target classes from different
    domains, i.e. eventually more useful.
    Usage
    Two-Argument Template Forms
    General Considerations
    The arguments to a binary operator commonly have identical types, but
    it is not unusual to want to define operators which combine different
    types. For example, one might want to multiply a
    mathematical vector by a scalar. The two-argument template forms of the
    arithmetic operator templates are supplied for this purpose. When
    applying the two-argument form of a template, the desired return type of
    the operators typically determines which of the two types in question
    should be derived from the operator template. For example, if the result
    of T + U is of type T, then
    T (not U) should be derived from addable<T, U>. The comparison templates
    (less_than_comparable<T,
    U>, equality_comparable<T, U>,
    equivalent<T, U>, and
    partially_ordered<T,
    U>) are exceptions to this guideline, since the return type
    of the operators they define is bool.
    On compilers which do not support partial specialization, the
    two-argument forms must be specified by using the names shown below with
    the trailing '2'. The single-argument forms with the
    trailing '1' are provided for symmetry and to enable certain
    applications of the base class chaining
    technique.
    Mixed Arithmetics
    Another application of the two-argument template forms is for mixed
    arithmetics between a type T and a type U that
    is convertible to T. In this case there are two ways where
    the two-argument template forms are helpful: one is to provide the
    respective signatures for operator overloading, the second is
    performance.
    With respect to the operator overloading assume e.g. that
    U is int, that T is an
    user-defined unlimited integer type, and that double
    operator-(double, const T&) exists. If one wants to compute
    int - T and does not provide T operator-(int, const
    T&), the compiler will consider double operator-(double,
    const T&) to be a better match than T operator-(const
    T&, const T&), which will probably be different from the
    user's intention. To define a complete set of operator signatures,
    additional 'left' forms of the two-argument template forms are provided
    (subtractable2_left<T,
    U>, dividable2_left<T,
    U>, modable2_left<T,
    U>) that define the signatures for non-commutative
    operators where U appears on the left hand side
    (operator-(const U&, const T&),
    operator/(const U&, const T&), operator%(const
    U&, const T&)).
    With respect to the performance observe that when one uses the single
    type binary operator for mixed type arithmetics, the type U
    argument has to be converted to type T. In practice,
    however, there are often more efficient implementations of, say
    T::operator-=(const U&) that avoid unnecessary
    conversions from U to T. The two-argument
    template forms of the arithmetic operator create additional operator
    interfaces that use these more efficient implementations. There is,
    however, no performance gain in the 'left' forms: they still need a
    conversion from U to T and have an
    implementation equivalent to the code that would be automatically created
    by the compiler if it considered the single type binary operator to be
    the best match.
    Base Class Chaining and Object Size
    Every operator class template, except the arithmetic examples and the iterator
    helpers, has an additional, but optional, template type parameter
    B. This parameter will be a publicly-derived base class of
    the instantiated template. This means it must be a class type. It can be
    used to avoid the bloating of object sizes that is commonly associated
    with multiple-inheritance from several empty base classes (see the note for users of older versions for more
    details). To provide support for a group of operators, use the
    B parameter to chain operator templates into a single-base
    class hierarchy, demostrated in the usage example.
    The technique is also used by the composite operator templates to group
    operator definitions. If a chain becomes too long for the compiler to
    support, try replacing some of the operator templates with a single
    grouped operator template that chains the old templates together; the
    length limit only applies to the number of templates directly in the
    chain, not those hidden in group templates.
    Caveat: to chain to a base class which is
    not a Boost operator template when using the single-argument form of a Boost operator template, you
    must specify the operator template with the trailing '1' in
    its name. Otherwise the library will assume you mean to define a binary
    operation combining the class you intend to use as a base class and the
    class you're deriving.
    Separate, Explicit
    Instantiation
    On some compilers (e.g. Borland, GCC) even single-inheritance
    seems to cause an increase in object size in some cases. If you are not
    defining a class template, you may get better object-size performance by
    avoiding derivation altogether, and instead explicitly instantiating the
    operator template as follows:
    
    class myclass // lose the inheritance...
    {
        //...
    };
    // explicitly instantiate the operators I need.
    template struct less_than_comparable<myclass>;
    template struct equality_comparable<myclass>;
    template struct incrementable<myclass>;
    template struct decrementable<myclass>;
    template struct addable<myclass,long>;
    template struct subtractable<myclass,long>;
    
    Note that some operator templates cannot use this workaround and must
    be a base class of their primary operand type. Those templates define
    operators which must be member functions, and the workaround needs the
    operators to be independent friend functions. The relevant templates
    are:
    
      dereferenceable<>
      indexable<>
      Any composite operator template that includes at least one of the
      above
    
    As Daniel Krgler pointed out, this technique violates 14.6.5/2
    and is thus non-portable. The reasoning is, that the operators injected
    by the instantiation of e.g.
    less_than_comparable<myclass> can not be found
    by ADL according to the rules given by 3.4.2/2, since myclass is
    not an associated class of
    less_than_comparable<myclass>.
    Thus only use this technique if all else fails.
    Requirement Portability
    Many compilers (e.g. MSVC 6.3, GCC 2.95.2) will not enforce the
    requirements in the operator template tables unless the operations which
    depend on them are actually used. This is not standard-conforming
    behavior. In particular, although it would be convenient to derive all
    your classes which need binary operators from the operators<> and operators2<> templates, regardless of
    whether they implement all the requirements of those templates, this
    shortcut is not portable. Even if this currently works with your
    compiler, it may not work later.
    Example
    This example shows how some of the arithmetic
    operator templates can be used with a geometric point class
    (template).
template <class T>
class point    // note: private inheritance is OK here!
    : boost::addable< point<T>          // point + point
    , boost::subtractable< point<T>     // point - point
    , boost::dividable2< point<T>, T    // point / T
    , boost::multipliable2< point<T>, T // point * T, T * point
      > > > >
{
public:
    point(T, T);
    T x() const;
    T y() const;
    point operator+=(const point&);
    // point operator+(point, const point&) automatically
    // generated by addable.
    point operator-=(const point&);
    // point operator-(point, const point&) automatically
    // generated by subtractable.
    point operator*=(T);
    // point operator*(point, const T&) and
    // point operator*(const T&, point) auto-generated
    // by multipliable.
    point operator/=(T);
    // point operator/(point, const T&) auto-generated
    // by dividable.
private:
    T x_;
    T y_;
};
// now use the point<> class:
template <class T>
T length(const point<T> p)
{
    return sqrt(p.x()*p.x() + p.y()*p.y());
}
const point<float> right(0, 1);
const point<float> up(1, 0);
const point<float> pi_over_4 = up + right;
const point<float> pi_over_4_normalized = pi_over_4 / length(pi_over_4);
    Arithmetic Operators
    The arithmetic operator templates ease the task of creating a custom
    numeric type. Given a core set of operators, the templates add related
    operators to the numeric class. These operations are like the ones the
    standard arithmetic types have, and may include comparisons, adding,
    incrementing, logical and bitwise manipulations, etc. Further,
    since most numeric types need more than one of these operators, some
    templates are provided to combine several of the basic operator templates
    in one declaration.
    The requirements for the types used to instantiate the simple operator
    templates are specified in terms of expressions which must be valid and
    the expression's return type. The composite operator templates only list
    what other templates they use. The supplied operations and requirements
    of the composite operator templates can be inferred from the operations
    and requirements of the listed components.
    Simple Arithmetic Operators
    These templates are "simple" since they provide operators based on a
    single operation the base type has to provide. They have an additional
    optional template parameter B, which is not shown, for the
    base class chaining technique.
    The primary operand type T needs to be of class type,
    built-in types are not supported.
    
      
        Simple Arithmetic Operator Template Classes
      
      
        
          
            
              Key
            
            
              T: primary operand type
              U: alternate operand type
            
            
              t, t1: values of type
              T
              u: value of type U
            
          
        
      
      
        Template
        Supplied Operations
        Requirements
      
      
        less_than_comparable<T>
         less_than_comparable1<T>
        bool operator>(const T&, const T&)
         bool operator<=(const T&, const T&)
         bool operator>=(const T&, const T&)
        t < t1.
         Return convertible to bool. See the Ordering Note.
      
      
        less_than_comparable<T,
        U>
         less_than_comparable2<T, U>
        bool operator<=(const T&, const U&)
         bool operator>=(const T&, const U&)
         bool operator>(const U&, const T&)
         bool operator<(const U&, const T&)
         bool operator<=(const U&, const T&)
         bool operator>=(const U&, const T&)
        t < u. t > u.
         Returns convertible to bool. See the Ordering Note.
      
      
        equality_comparable<T>
         equality_comparable1<T>
        bool operator!=(const T&, const T&)
        t == t1.
         Return convertible to bool.
      
      
        equality_comparable<T,
        U>
         equality_comparable2<T, U>
        bool operator==(const U&, const T&)
         bool operator!=(const U&, const T&)
         bool operator!=(const T&, const U&)
        t == u.
         Return convertible to bool.
      
      
        addable<T>
         addable1<T>
        T operator+(const T&, const T&)
        T temp(t); temp += t1.
         Return convertible to T. See the Symmetry Note.
      
      
        addable<T, U>
         addable2<T, U>
        T operator+(const T&, const U&)
         T operator+(const U&, const T& )
        T temp(t); temp += u.
         Return convertible to T. See the Symmetry Note.
      
      
        subtractable<T>
         subtractable1<T>
        T operator-(const T&, const T&)
        T temp(t); temp -= t1.
         Return convertible to T. See the Symmetry Note.
      
      
        subtractable<T,
        U>
         subtractable2<T, U>
        T operator-(const T&, const U&)
        T temp(t); temp -= u.
         Return convertible to T. See the Symmetry Note.
      
      
        subtractable2_left<T,
        U>
        T operator-(const U&, const T&)
        T temp(u); temp -= t.
         Return convertible to T.
      
      
        multipliable<T>
         multipliable1<T>
        T operator*(const T&, const T&)
        T temp(t); temp *= t1.
         Return convertible to T. See the Symmetry Note.
      
      
        multipliable<T,
        U>
         multipliable2<T, U>
        T operator*(const T&, const U&)
         T operator*(const U&, const T&)
        T temp(t); temp *= u.
         Return convertible to T. See the Symmetry Note.
      
      
        dividable<T>
         dividable1<T>
        T operator/(const T&, const T&)
        T temp(t); temp /= t1.
         Return convertible to T. See the Symmetry Note.
      
      
        dividable<T, U>
         dividable2<T, U>
        T operator/(const T&, const U&)
        T temp(t); temp /= u.
         Return convertible to T. See the Symmetry Note.
      
      
        dividable2_left<T,
        U>
        T operator/(const U&, const T&)
        T temp(u); temp /= t.
         Return convertible to T.
      
      
        modable<T>
         modable1<T>
        T operator%(const T&, const T&)
        T temp(t); temp %= t1.
         Return convertible to T. See the Symmetry Note.
      
      
        modable<T, U>
         modable2<T, U>
        T operator%(const T&, const U&)
        T temp(t); temp %= u.
         Return convertible to T. See the Symmetry Note.
      
      
        modable2_left<T,
        U>
        T operator%(const U&, const T&)
        T temp(u); temp %= t.
         Return convertible to T.
      
      
        orable<T>
         orable1<T>
        T operator|(const T&, const T&)
        T temp(t); temp |= t1.
         Return convertible to T. See the Symmetry Note.
      
      
        orable<T, U>
         orable2<T, U>
        T operator|(const T&, const U&)
         T operator|(const U&, const T&)
        T temp(t); temp |= u.
         Return convertible to T. See the Symmetry Note.
      
      
        andable<T>
         andable1<T>
        T operator&(const T&, const T&)
        T temp(t); temp &= t1.
         Return convertible to T. See the Symmetry Note.
      
      
        andable<T, U>
         andable2<T, U>
        T operator&(const T&, const U&)
         T operator&(const U&, const T&)
        T temp(t); temp &= u.
         Return convertible to T. See the Symmetry Note.
      
      
        xorable<T>
         xorable1<T>
        T operator^(const T&, const T&)
        T temp(t); temp ^= t1.
         Return convertible to T. See the Symmetry Note.
      
      
        xorable<T, U>
         xorable2<T, U>
        T operator^(const T&, const U&)
         T operator^(const U&, const T&)
        T temp(t); temp ^= u.
         Return convertible to T. See the Symmetry Note.
      
      
        incrementable<T>
        T operator++(T&, int)
        T temp(t); ++t
         Return convertible to T.
      
      
        decrementable<T>
        T operator--(T&, int)
        T temp(t); --t;
         Return convertible to T.
      
      
        left_shiftable<T>
         left_shiftable1<T>
        T operator<<(const T&, const T&)
        T temp(t); temp <<= t1.
         Return convertible to T. See the Symmetry Note.
      
      
        left_shiftable<T,
        U>
         left_shiftable2<T, U>
        T operator<<(const T&, const U&)
        T temp(t); temp <<= u.
         Return convertible to T. See the Symmetry Note.
      
      
        right_shiftable<T>
         right_shiftable1<T>
        T operator>>(const T&, const T&)
        T temp(t); temp >>= t1.
         Return convertible to T. See the Symmetry Note.
      
      
        right_shiftable<T,
        U>
         right_shiftable2<T, U>
        T operator>>(const T&, const U&)
        T temp(t); temp >>= u.
         Return convertible to T. See the Symmetry Note.
      
      
        equivalent<T>
         equivalent1<T>
        bool operator==(const T&, const T&)
        t < t1.
         Return convertible to bool. See the Ordering Note.
      
      
        equivalent<T, U>
         equivalent2<T, U>
        bool operator==(const T&, const U&)
        t < u. t > u.
         Returns convertible to bool. See the Ordering Note.
      
      
        partially_ordered<T>
         partially_ordered1<T>
        bool operator>(const T&, const T&)
         bool operator<=(const T&, const T&)
         bool operator>=(const T&, const T&)
        t < t1. t == t1.
         Returns convertible to bool. See the Ordering Note.
      
      
        partially_ordered<T,
        U>
         partially_ordered2<T, U>
        bool operator<=(const T&, const U&)
         bool operator>=(const T&, const U&)
         bool operator>(const U&, const T&)
         bool operator<(const U&, const T&)
         bool operator<=(const U&, const T&)
         bool operator>=(const U&, const T&)
        t < u. t > u. t ==
        u.
         Returns convertible to bool. See the Ordering Note.
      
    
    Ordering Note
    The less_than_comparable<T> and
    partially_ordered<T>
    templates provide the same set of operations. However, the workings of
    less_than_comparable<T> assume
    that all values of type T can be placed in a total order. If
    that is not true (e.g. Not-a-Number values in IEEE floating point
    arithmetic), then partially_ordered<T> should be
    used. The partially_ordered<T> template can
    be used for a totally-ordered type, but it is not as efficient as
    less_than_comparable<T>. This
    rule also applies for less_than_comparable<T, U> and
    partially_ordered<T,
    U> with respect to the ordering of all T and
    U values, and for both versions of equivalent<>. The solution for equivalent<> is to write a custom
    operator== for the target class.
    Symmetry Note
    Before talking about symmetry, we need to talk about optimizations to
    understand the reasons for the different implementation styles of
    operators. Let's have a look at operator+ for a class
    T as an example:
T operator+( const T& lhs, const T& rhs )
{
   return T( lhs ) += rhs;
}
    This would be a normal implementation of operator+, but it
    is not an efficient one. An unnamed local copy of lhs is
    created, operator+= is called on it and it is copied to the
    function return value (which is another unnamed object of type
    T). The standard doesn't generally allow the intermediate
    object to be optimized away:
    
      3.7.2/2: Automatic storage duration
      
       If a named automatic object has initialization or a destructor with
      side effects, it shall not be destroyed before the end of its block,
      nor shall it be eliminated as an optimization even if it appears to be
      unused, except that a class object or its copy may be eliminated as
      specified in 12.8.
    
    The reference to 12.8 is important for us:
    
      12.8/15: Copying class objects
       ...
       For a function with a class return type, if the expression in the
      return statement is the name of a local object, and the cv-unqualified
      type of the local object is the same as the function return type, an
      implementation is permitted to omit creating the temporary object to
      hold the function return value, even if the class copy constructor or
      destructor has side effects.
    
    This optimization is known as the named return value optimization (NRVO),
    which leads us to the following implementation for
    operator+:
T operator+( const T& lhs, const T& rhs )
{
   T nrv( lhs );
   nrv += rhs;
   return nrv;
}
    Given this implementation, the compiler is allowed to remove the
    intermediate object. Sadly, not all compiler implement the NRVO, some
    even implement it in an incorrect way which makes it useless here.
    Without the NRVO, the NRVO-friendly code is no worse than the original
    code showed above, but there is another possible implementation, which
    has some very special properties:
T operator+( T lhs, const T& rhs )
{
   return lhs += rhs;
}
    The difference to the first implementation is that lhs is
    not taken as a constant reference used to create a copy; instead,
    lhs is a by-value parameter, thus it is already the copy
    needed. This allows another optimization (12.2/2) for some cases.
    Consider a + b + c where the result of
    a + b is not copied when used as lhs
    when adding c. This is more efficient than the original
    code, but not as efficient as a compiler using the NRVO. For most people,
    it is still preferable for compilers that don't implement the NRVO, but
    the operator+ now has a different function signature. Also,
    the number of objects created differs for
    (a + b ) + c and
    a + ( b + c ). Most probably,
    this won't be a problem for you, but if your code relies on the function
    signature or a strict symmetric behaviour, you should set
    BOOST_FORCE_SYMMETRIC_OPERATORS in your user-config. This
    will force the NRVO-friendly implementation to be used even for compilers
    that don't implement the NRVO. 
     
    Grouped Arithmetic Operators
    The following templates provide common groups of related operations.
    For example, since a type which is addable is usually also subractable,
    the additive template provides the
    combined operators of both. The grouped operator templates have an
    additional optional template parameter B, which is not
    shown, for the base class chaining technique.
    
      
        Grouped Arithmetic Operator Template Classes
      
      
        
          
            
              Key
            
            
              T: primary operand type
              U: alternate operand type
            
          
        
      
      
        Template
        Component Operator Templates
      
      
        totally_ordered<T>
         totally_ordered1<T>
        
          
            less_than_comparable<T>
            equality_comparable<T>
          
        
      
      
        totally_ordered<T,
        U>
         totally_ordered2<T, U>
        
          
            less_than_comparable<T,
            U>
            equality_comparable<T,
            U>
          
        
      
      
        additive<T>
         additive1<T>
        
          
            addable<T>
            subtractable<T>
          
        
      
      
        additive<T, U>
         additive2<T, U>
        
          
            addable<T, U>
            subtractable<T,
            U>
          
        
      
      
        multiplicative<T>
         multiplicative1<T>
        
          
            multipliable<T>
            dividable<T>
          
        
      
      
        multiplicative<T,
        U>
         multiplicative2<T, U>
        
          
            multipliable<T,
            U>
            dividable<T,
            U>
          
        
      
      
        integer_multiplicative<T>
         integer_multiplicative1<T>
        
          
            multiplicative<T>
            modable<T>
          
        
      
      
        integer_multiplicative<T,
        U>
         integer_multiplicative2<T, U>
        
          
            multiplicative<T,
            U>
            modable<T, U>
          
        
      
      
        arithmetic<T>
         arithmetic1<T>
        
          
            additive<T>
            multiplicative<T>
          
        
      
      
        arithmetic<T, U>
         arithmetic2<T, U>
        
          
            additive<T,
            U>
            multiplicative<T,
            U>
          
        
      
      
        integer_arithmetic<T>
         integer_arithmetic1<T>
        
          
            additive<T>
            integer_multiplicative<T>
          
        
      
      
        integer_arithmetic<T,
        U>
         integer_arithmetic2<T, U>
        
          
            additive<T,
            U>
            integer_multiplicative<T,
            U>
          
        
      
      
        bitwise<T>
         bitwise1<T>
        
          
            xorable<T>
            andable<T>
            orable<T>
          
        
      
      
        bitwise<T, U>
         bitwise2<T, U>
        
          
            xorable<T, U>
            andable<T, U>
            orable<T, U>
          
        
      
      
        unit_steppable<T>
        
          
            incrementable<T>
            decrementable<T>
          
        
      
      
        shiftable<T>
         shiftable1<T>
        
          
            left_shiftable<T>
            right_shiftable<T>
          
        
      
      
        shiftable<T, U>
         shiftable2<T, U>
        
          
            left_shiftable<T,
            U>
            right_shiftable<T,
            U>
          
        
      
      
        ring_operators<T>
         ring_operators1<T>
        
          
            additive<T>
            multipliable<T>
          
        
      
      
        ring_operators<T,
        U>
         ring_operators2<T, U>
        
          
            additive<T,
            U>
            subtractable2_left<T,
            U>
            multipliable<T,
            U>
          
        
      
      
        ordered_ring_operators<T>
         ordered_ring_operators1<T>
        
          
            ring_operators<T>
            totally_ordered<T>
          
        
      
      
        ordered_ring_operators<T,
        U>
         ordered_ring_operators2<T, U>
        
          
            ring_operators<T,
            U>
            totally_ordered<T,
            U>
          
        
      
      
        field_operators<T>
         field_operators1<T>
        
          
            ring_operators<T>
            dividable<T>
          
        
      
      
        field_operators<T,
        U>
         field_operators2<T, U>
        
          
            ring_operators<T,
            U>
            dividable<T,
            U>
            dividable2_left<T,
            U>
          
        
      
      
        ordered_field_operators<T>
         ordered_field_operators1<T>
        
          
            field_operators<T>
            totally_ordered<T>
          
        
      
      
        ordered_field_operators<T,
        U>
         ordered_field_operators2<T, U>
        
          
            field_operators<T,
            U>
            totally_ordered<T,
            U>
          
        
      
      
        euclidean_ring_operators<T>
         euclidean_ring_operators1<T>
        
          
            ring_operators<T>
            dividable<T>
            modable<T>
          
        
      
      
        euclidean_ring_operators<T,
        U>
         euclidean_ring_operators2<T, U>
        
          
            ring_operators<T,
            U>
            dividable<T,
            U>
            dividable2_left<T,
            U>
            modable<T, U>
            modable2_left<T,
            U>
          
        
      
      
        ordered_euclidean_ring_operators<T>
         ordered_euclidean_ring_operators1<T>
        
          
            euclidean_ring_operators<T>
            totally_ordered<T>
          
        
      
      
        ordered_euclidean_ring_operators<T,
        U>
         ordered_euclidean_ring_operators2<T, U>
        
          
            euclidean_ring_operators<T,
            U>
            totally_ordered<T,
            U>
          
        
      
    
    Spelling: euclidean vs. euclidian
    Older versions of the Boost.Operators library used
    "euclidian", but it was pointed out that
    "euclidean" is the more common spelling.
    To be compatible with older version, the library now supports
    both spellings.
    
    Example Templates
    The arithmetic operator class templates operators<> and operators2<> are examples of
    non-extensible operator grouping classes. These legacy class templates,
    from previous versions of the header, cannot be used for base class chaining.
    
      
        Final Arithmetic Operator Template Classes
      
      
        
          
            
              Key
            
            
              T: primary operand type
              U: alternate operand type
            
          
        
      
      
        Template
        Component Operator Templates
      
      
        operators<T>
        
          
            totally_ordered<T>
            integer_arithmetic<T>
            bitwise<T>
            unit_steppable<T>
          
        
      
      
        operators<T, U>
         operators2<T, U>
        
          
            totally_ordered<T,
            U>
            integer_arithmetic<T,
            U>
            bitwise<T, U>
          
        
      
    
    Arithmetic Operators Demonstration and Test
    Program
    The operators_test.cpp
    program demonstrates the use of the arithmetic operator templates, and
    can also be used to verify correct operation. Check the compiler status
    report for the test results with selected platforms.
    Dereference Operators and Iterator Helpers
    The iterator helper templates ease the task of
    creating a custom iterator. Similar to arithmetic types, a complete
    iterator has many operators that are "redundant" and can be implemented
    in terms of the core set of operators.
    The dereference operators were motivated by
    the iterator helpers, but are often useful in
    non-iterator contexts as well. Many of the redundant iterator operators
    are also arithmetic operators, so the iterator helper classes borrow many
    of the operators defined above. In fact, only two new operators need to
    be defined (the pointer-to-member operator-> and the
    subscript operator[])!
    The requirements for the types used to instantiate the dereference
    operators are specified in terms of expressions which must be valid and
    their return type. The composite operator templates list their component
    templates, which the instantiating type must support, and possibly other
    requirements.
    Dereference Operators
    All the dereference operator templates in this table accept an
    optional template parameter (not shown) to be used for base class chaining.
    
      
        Dereference Operator Template Classes
      
      
        
          
            
              Key
            
            
              T: operand type
              P: pointer type
            
            
              D: difference_type
              R: reference type
            
            
              i: object of type T (an
              iterator)
              n: object of type D (an
              index)
            
          
        
      
      
        Template
        Supplied Operations
        Requirements
      
      
        dereferenceable<T,
        P>
        P operator->() const
        (&*i). Return convertible to
        P.
      
      
        indexable<T, D,
        R>
        R operator[](D n) const
        *(i + n). Return of type
        R.
      
    
    Grouped Iterator Operators
    There are five iterator operator class templates, each for a different
    category of iterator. The following table shows the operator groups for
    any category that a custom iterator could define. These class templates
    have an additional optional template parameter B, which is
    not shown, to support base class chaining.
    
      
        Iterator Operator Class Templates
      
      
        
          
            
              Key
            
            
              T: operand type
              P: pointer type
            
            
              D: difference_type
              R: reference type
            
            
              V: value_type
              
              
            
          
        
      
      
        Template
        Component Operator Templates
      
      
        input_iteratable<T,
        P>
        
          
            equality_comparable<T>
            incrementable<T>
            dereferenceable<T,
            P>
          
        
      
      
        output_iteratable<T>
        
          
            incrementable<T>
          
        
      
      
        forward_iteratable<T,
        P>
        
          
            input_iteratable<T,
            P>
          
        
      
      
        bidirectional_iteratable<T,
        P>
        
          
            forward_iteratable<T,
            P>
            decrementable<T>
          
        
      
      
        random_access_iteratable<T, P, D,
        R>
        
          
            bidirectional_iteratable<T,
            P>
            totally_ordered<T>
            additive<T,
            D>
            indexable<T, D,
            R>
          
        
      
    
    Iterator Helpers
    There are also five iterator helper class templates, each
    corresponding to a different iterator category. These classes cannot be
    used for base class chaining. The following
    summaries show that these class templates supply both the iterator
    operators from the iterator operator class
    templates and the iterator typedef's required by the C++ standard
    (iterator_category, value_type,
    etc.).
    
      
        Iterator Helper Class Templates
      
      
        
          
            
              Key
            
            
              T: operand type
              P: pointer type
            
            
              D: difference_type
              R: reference type
            
            
              V: value_type
              x1, x2: objects of type T
            
          
        
      
      
        Template
        Operations & Requirements
      
      
        input_iterator_helper<T,
        V, D, P, R>
        
          Supports the operations and has the requirements of
          
            input_iteratable<T,
            P>
          
        
      
      
        output_iterator_helper<T>
        
          Supports the operations and has the requirements of
          
            output_iteratable<T>
          
          See also [1], [2].
        
      
      
        forward_iterator_helper<T, V, D, P,
        R>
        
          Supports the operations and has the requirements of
          
            forward_iteratable<T,
            P>
          
        
      
      
        bidirectional_iterator_helper<T,
        V, D, P, R>
        
          Supports the operations and has the requirements of
          
            bidirectional_iteratable<T,
            P>
          
        
      
      
        random_access_iterator_helper<T,
        V, D, P, R>
        
          Supports the operations and has the requirements of
          
            random_access_iteratable<T, P, D,
            R>
          
          To satisfy RandomAccessIterator,
          x1 - x2 with return convertible to D is
          also required.
        
      
    
    Iterator Helper Notes
    [1] Unlike other iterator helpers templates,
    output_iterator_helper takes only one template parameter -
    the type of its target class. Although to some it might seem like an
    unnecessary restriction, the standard requires
    difference_type and value_type of any output
    iterator to be void (24.3.1 [lib.iterator.traits]), and
    output_iterator_helper template respects this requirement.
    Also, output iterators in the standard have void pointer and
    reference types, so the output_iterator_helper
    does the same.
    [2] As self-proxying is the easiest and most common
    way to implement output iterators (see, for example, insert [24.4.2] and
    stream iterators [24.5] in the standard library),
    output_iterator_helper supports the idiom by defining
    operator* and operator++ member functions which
    just return a non-const reference to the iterator itself. Support for
    self-proxying allows us, in many cases, to reduce the task of writing an
    output iterator to writing just two member functions - an appropriate
    constructor and a copy-assignment operator. For example, here is a
    possible implementation of boost::function_output_iterator
    adaptor:
template<class UnaryFunction>
struct function_output_iterator
    : boost::output_iterator_helper< function_output_iterator<UnaryFunction> >
{
    explicit function_output_iterator(UnaryFunction const& f = UnaryFunction())
        : func(f) {}
    template<typename T>
    function_output_iterator& operator=(T const& value)
    {
        this->func(value);
        return *this;
    }
 private:
    UnaryFunction func;
};
    Note that support for self-proxying does not prevent you from using
    output_iterator_helper to ease any other, different kind of
    output iterator's implementation. If
    output_iterator_helper's target type provides its own
    definition of operator* or/and operator++, then
    these operators will get used and the ones supplied by
    output_iterator_helper will never be instantiated.
    Iterator Demonstration and Test Program
    The iterators_test.cpp
    program demonstrates the use of the iterator templates, and can also be
    used to verify correct operation. The following is the custom iterator
    defined in the test program. It demonstrates a correct (though trivial)
    implementation of the core operations that must be defined in order for
    the iterator helpers to "fill in" the rest of the iterator
    operations.
    
template <class T, class R, class P>
struct test_iter
  : public boost::random_access_iterator_helper<
     test_iter<T,R,P>, T, std::ptrdiff_t, P, R>
{
  typedef test_iter self;
  typedef R Reference;
  typedef std::ptrdiff_t Distance;
public:
  explicit test_iter(T* i =0);
  test_iter(const self& x);
  self& operator=(const self& x);
  Reference operator*() const;
  self& operator++();
  self& operator--();
  self& operator+=(Distance n);
  self& operator-=(Distance n);
  bool operator==(const self& x) const;
  bool operator<(const self& x) const;
  friend Distance operator-(const self& x, const self& y);
};
    
    Check the compiler status
    report for the test results with selected platforms.
    
    Contributors
    
      Dave Abrahams
      Started the library and contributed the arithmetic operators in
      boost/operators.hpp.
      Jeremy Siek
      Contributed the dereference operators and iterator
      helpers in boost/operators.hpp. Also
      contributed iterators_test.cpp.
      Aleksey
      Gurtovoy
      Contributed the code to support base class
      chaining while remaining backward-compatible with old versions of
      the library.
      Beman Dawes
      Contributed operators_test.cpp.
      Daryle Walker
      Contributed classes for the shift operators, equivalence, partial
      ordering, and arithmetic conversions. Added the grouped operator
      classes. Added helper classes for input and output iterators.
      Helmut Zeisel
      Contributed the 'left' operators and added some grouped operator
      classes.
      Daniel Frey
      Contributed the NRVO-friendly and symmetric implementation of
      arithmetic operators.
    
    Note for Users of Older Versions
    The changes in the library interface and
    recommended usage were motivated by some practical issues described
    below. The new version of the library is still backward-compatible with
    the former one (so you're not forced change any existing code),
    but the old usage is deprecated. Though it was arguably simpler and more
    intuitive than using base class chaining, it has
    been discovered that the old practice of deriving from multiple operator
    templates can cause the resulting classes to be much larger than they
    should be. Most modern C++ compilers significantly bloat the size of
    classes derived from multiple empty base classes, even though the base
    classes themselves have no state. For instance, the size of
    point<int> from the example
    above was 12-24 bytes on various compilers for the Win32 platform,
    instead of the expected 8 bytes.
    Strictly speaking, it was not the library's fault--the language rules
    allow the compiler to apply the empty base class optimization in that
    situation. In principle an arbitrary number of empty base classes can be
    allocated at the same offset, provided that none of them have a common
    ancestor (see section 10.5 [class.derived] paragraph 5 of the standard).
    But the language definition also doesn't require implementations
    to do the optimization, and few if any of today's compilers implement it
    when multiple inheritance is involved. What's worse, it is very unlikely
    that implementors will adopt it as a future enhancement to existing
    compilers, because it would break binary compatibility between code
    generated by two different versions of the same compiler. As Matt Austern
    said, "One of the few times when you have the freedom to do this sort of
    thing is when you're targeting a new architecture...". On the other hand,
    many common compilers will use the empty base optimization for single
    inheritance hierarchies.
    Given the importance of the issue for the users of the library (which
    aims to be useful for writing light-weight classes like
    MyInt or point<>), and the forces
    described above, we decided to change the library interface so that the
    object size bloat could be eliminated even on compilers that support only
    the simplest form of the empty base class optimization. The current
    library interface is the result of those changes. Though the new usage is
    a bit more complicated than the old one, we think it's worth it to make
    the library more useful in real world. Alexy Gurtovoy contributed the
    code which supports the new usage idiom while allowing the library remain
    backward-compatible.
    
    Revised: 7 Aug 2008
    Copyright  Beman Dawes, David Abrahams, 1999-2001.
    Copyright  Daniel Frey, 2002-2009.
    Use, modification, and distribution is subject to the Boost Software
    License, Version 1.0. (See accompanying file
    LICENSE_1_0.txt or copy at
    
    www.boost.org/LICENSE_1_0.txt)
  
