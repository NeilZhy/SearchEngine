<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
Chapter 31. Boost.Proto - 1.63.0
  
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
This is the documentation for an old version of Boost.
                Click here to view this page for the latest version.
Chapter 31. Boost.Proto
Eric Niebler
Copyright  2008 Eric Niebler
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      
Table of Contents
Preface
Users' Guide
Getting Started
Fronts Ends: Defining
      Terminals and Non-Terminals of Your EDSL
Intermediate
      Form: Understanding and Introspecting Expressions
Back Ends: Making Expression
      Templates Do Useful Work
Examples
Background and Resources
Glossary
Reference
Concepts
Classes
Functions
Header <boost/proto/args.hpp>
Header <boost/proto/core.hpp>
Header <boost/proto/debug.hpp>
Header <boost/proto/deep_copy.hpp>
Header <boost/proto/domain.hpp>
Header <boost/proto/eval.hpp>
Header <boost/proto/expr.hpp>
Header <boost/proto/extends.hpp>
Header <boost/proto/functional.hpp>
Header <boost/proto/functional/fusion.hpp>
Header <boost/proto/functional/fusion/at.hpp>
Header <boost/proto/functional/fusion/pop_back.hpp>
Header <boost/proto/functional/fusion/pop_front.hpp>
Header <boost/proto/functional/fusion/push_back.hpp>
Header <boost/proto/functional/fusion/push_front.hpp>
Header <boost/proto/functional/fusion/reverse.hpp>
Header <boost/proto/functional/range/begin.hpp>
Header <boost/proto/functional/range/empty.hpp>
Header <boost/proto/functional/range/end.hpp>
Header <boost/proto/functional/range/rbegin.hpp>
Header <boost/proto/functional/range/rend.hpp>
Header <boost/proto/functional/range/size.hpp>
Header <boost/proto/functional/std.hpp>
Header <boost/proto/functional/std/iterator.hpp>
Header <boost/proto/functional/std/utility.hpp>
Header <boost/proto/fusion.hpp>
Header <boost/proto/generate.hpp>
Header <boost/proto/literal.hpp>
Header <boost/proto/make_expr.hpp>
Header <boost/proto/matches.hpp>
Header <boost/proto/operators.hpp>
Header <boost/proto/proto.hpp>
Header <boost/proto/proto_fwd.hpp>
Header <boost/proto/proto_typeof.hpp>
Header <boost/proto/repeat.hpp>
Header <boost/proto/tags.hpp>
Header <boost/proto/traits.hpp>
Header <boost/proto/transform.hpp>
Header <boost/proto/transform/arg.hpp>
Header <boost/proto/transform/call.hpp>
Header <boost/proto/transform/default.hpp>
Header <boost/proto/transform/env.hpp>
Header <boost/proto/transform/fold.hpp>
Header <boost/proto/transform/fold_tree.hpp>
Header <boost/proto/transform/impl.hpp>
Header <boost/proto/transform/integral_c.hpp>
Header <boost/proto/transform/lazy.hpp>
Header <boost/proto/transform/make.hpp>
Header <boost/proto/transform/pass_through.hpp>
Header <boost/proto/transform/when.hpp>
Header <boost/proto/context.hpp>
Header <boost/proto/context/callable.hpp>
Header <boost/proto/context/default.hpp>
Header <boost/proto/context/null.hpp>
Appendices
Appendix A: Release
      Notes
Appendix B: History
Appendix C: Rationale
Appendix D: Implementation
      Notes
Appendix E:
      Acknowledgements
Preface
        There are more things in heaven and earth, Horatio, than are dreamt
        of in your philosophy.
      
        -- William Shakespeare
      
      Description
    
      Proto is a framework for building Embedded Domain-Specific Languages in C++.
      It provides tools for constructing, type-checking, transforming and executing
      expression templates[6]. More specifically, Proto provides:
    
          An expression tree data structure.
        
          A mechanism for giving expressions additional behaviors and members.
        
          Operator overloads for building the tree from an expression.
        
          Utilities for defining the grammar to which an expression must conform.
        
          An extensible mechanism for immediately executing an expression template.
        
          An extensible set of tree transformations to apply to expression trees.
        
      Motivation
    
      Expression Templates are an advanced technique that C++ library developers
      use to define embedded mini-languages that target specific problem domains.
      The technique has been used to create efficient and easy-to-use libraries for
      linear algebra as well as to define C++ parser generators with a readable syntax.
      But developing such a library involves writing an inordinate amount of unreadable
      and unmaintainable template mumbo-jumbo. Boost.Proto eases the development
      of domain-specific embedded
      languages (EDSLs). Use Proto to define the primitives of your mini-language
      and let Proto handle the operator overloading and the construction of the expression
      parse tree. Immediately evaluate the expression tree by passing it a function
      object. Or transform the expression tree by defining the grammar of your mini-language,
      decorated with an assortment of tree transforms provided by Proto or defined
      by you. Then use the grammar to give your users short and readable syntax errors
      for invalid expressions! No more mumbo-jumbo -- an expression template library
      developed with Proto is declarative and readable.
    
      In short, Proto is an EDSL for defining EDSLs.
    
      How
      to Use This Documentation
    
      This documentation makes use of the following naming and formatting conventions.
    
          Code is in fixed width
          font and is syntax-highlighted.
        
          Replaceable text that you will need to supply is in italics.
        
          If a name refers to a free function, it is specified like this: free_function();
          that is, it is in code font and its name is followed by ()
          to indicate that it is a free function.
        
          If a name refers to a class template, it is specified like this: class_template<>;
          that is, it is in code font and its name is followed by <>
          to indicate that it is a class template.
        
          If a name refers to a function-like macro, it is specified like this:
          MACRO();
          that is, it is uppercase in code font and its name is followed by () to indicate that it is a function-like
          macro. Object-like macros appear without the trailing ().
        
          Names that refer to concepts in the generic programming
          sense are specified in CamelCase.
        
Note
        In addition, notes such as this one specify non-essential information that
        provides additional background or rationale.
      
      Finally, you can mentally add the following to any code fragments in this document:
    
// Include all of Proto
#include <boost/proto/proto.hpp>
// Create some namespace aliases
namespace mpl = boost::mpl;
namespace fusion = boost::fusion;
namespace proto = boost::proto;
// Allow unqualified use of Proto's wildcard pattern
using proto::_;
[6] 
        See Expression
        Templates
      
Last revised: December 22, 2016 at 12:37:41 GMT
