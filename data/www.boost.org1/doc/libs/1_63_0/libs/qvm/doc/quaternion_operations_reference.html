<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN'
'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>
	
	quaternion operations - 1.63.0
	
  
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
This is the documentation for an old version of Boost.
                Click here to view this page for the latest version.
QVM: Quaternions, Vectors, Matrices
Quaternion Operations
include <boost/qvm/quat_operations.hpp>
namespace boost
{
    namespace qvm
    {
        //*** Quaternion operations ***
        
        //Only enabled if:
        //  is_quat<A>::value && is_quat<B>::value
        template <class A,class B>
        A & assign( A & a, B const & b );        
        
        //Only enabled if:
        //  is_quat<R>::value && is_quat<A>::value
        template <class R,class A>
        R convert_to( A const & a );
        
        //Only enabled if:
        //  is_quat<R>::value && is_mat<A>::value &&
        //  mat_traits<A>::rows==3 && mat_traits<A>::cols==3
        template <class R,class A>
        R convert_to( A const & m );        
        
        //Only enabled if:
        //  is_quat<A>::value && is_quat<B>::value
        template <class A,class B>
        A & operator-=( A & a, B const & b );        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        typename deduce_quat<A>::type
        operator-( A const & a );        
        
        //Only enabled if:
        //  is_quat<A>::value && is_quat<B>::value &&
        template <class A,class B>
        typename deduce_quat2<A,B>::type
        operator-( A const & a, B const & b );        
        
        //Only enabled if:
        //  is_quat<A>::value && is_quat<B>::value
        template <class A,class B>
        A & operator+=( A & a, B const & b );        
        
        //Only enabled if:
        //  is_quat<A>::value && is_quat<B>::value &&
        template <class A,class B>
        typename deduce_quat2<A,B>::type
        operator+( A const & a, B const & b );        
        
        //Only enabled if: is_quat<A>::value && is_quat<B>::value
        template <class A,class B>
        A & operator/=( A & a, B b );        
        
        //Only enabled if: is_quat<A>::value && is_quat<B>::value
        template <class A,class B>
        typename deduce_quat<A>::type
        operator/( A const & a, B b );        
        
        //Only enabled if:
        //  is_quat<A>::value && is_quat<B>::value
        template <class A,class B>
        A & operator*=( A & a, B const & b );        
        
        //Only enabled if: is_quat<A>::value && is_quat<B>::value
        template <class A,class B>
        A & operator*=( A & a, B b );        
        
        //Only enabled if:
        //  is_quat<A>::value && is_quat<B>::value
        template <class A,class B>
        typename deduce_quat2<A,B>::type
        operator*( A const & a, B const & b );        
        
        //Only enabled if: is_quat<A>::value && is_quat<B>::value
        template <class A,class B>
        typename deduce_quat<A>::type
        operator*( A const & a, B b );        
        
        //Only enabled if:
        //  is_quat<A>::value && is_quat<B>::value
        template <class A,class B>
        bool operator==( A const & a, B const & b );        
        
        //Only enabled if:
        //  is_quat<A>::value && is_quat<B>::value
        template <class A,class B>
        bool operator!=( A const & a, B const & b );        
        
        //Only enabled if:
        //  is_quat<A>::value && is_quat<B>::value
        template <class A,class B,class Cmp>
        bool cmp( A const & a, B const & b, Cmp pred );        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        typename quat_traits<A>::scalar_type
        mag_sqr( A const & a );        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        typename quat_traits<A>::scalar_type
        mag( A const & a );        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        typename deduce_quat<A>::type
        normalized( A const & a );        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        void normalize( A & a );        
        
        //Only enabled if:
        //  is_quat<A>::value && is_quat<B>::value
        template <class A,class B>
        typename deduce_scalar<A,B>::type
        dot( A const & a, B const & b );        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        typename deduce_quat<A>::type
        conjugate( A const & a );        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        typename deduce_quat<A>::type
        inverse( A const & a );        
        
        //Only enabled if:
        //  is_quat<A>::value && is_quat<B>::value && is_scalar<C>
        template <class A,class B,class C>
        typename deduce_quat2<A,B> >::type
        slerp( A const & a, B const & b, C c );        
        
        template <class T>
        -unspecified-return-type- zero_quat();        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        void set_zero( A & a );        
        
        template <class S>
        -unspecified-return-type- identity_quat();        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        void set_identity( A & a );        
        
        //Only enabled if:
        //  is_vec<A>::value && vec_traits<A>::dim==3
        template <class A>
        -unspecified-return-type- rot_quat( A const & axis, typename vec_traits<A>::scalar_type angle );        
        
        //Only enabled if:
        //  is_quat<A>::value &&
        //  is_vec<B>::value && vec_traits<B>::dim==3
        template <class A>
        void set_rot( A & a, B const & axis, typename vec_traits<B>::scalar_type angle );        
        
        //Only enabled if:
        //  is_quat<A>::value &&
        //  is_vec<B>::value && vec_traits<B>::dim==3
        template <class A,class B>
        void rotate( A & a, B const & axis, typename quat_traits<A>::scalar_type angle );        
        
        template <class Angle>
        -unspecified-return-type- rotx_quat( Angle const & angle );        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        void set_rotx( A & a, typename quat_traits<A>::scalar_type angle );        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        void rotate_x( A & a, typename quat_traits<A>::scalar_type angle );        
        
        template <class Angle>
        -unspecified-return-type- roty_quat( Angle const & angle );        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        void set_rotz( A & a, typename quat_traits<A>::scalar_type angle );        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        void rotate_y( A & a, typename quat_traits<A>::scalar_type angle );        
        
        template <class Angle>
        -unspecified-return-type- rotz_quat( Angle const & angle );        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        void set_rotz( A & a, typename quat_traits<A>::scalar_type angle );        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        void rotate_z( A & a, typename quat_traits<A>::scalar_type angle );        
        
        //Only enabled if: is_quat<A>::value
        template <class Scalar,class A>
        -unspecified-return_type- scalar_cast( A const & a );        
        
        //Only enabled if: is_quat<A>::value
        template <class A>
        -unspecified-return-type- qref( A & a );
    }
}
This is a list of all quaternion operations implemented by Boost QVM -- click on functions for individual documentation. General notes:
 All functions use SFINAE/enable_if. They are available for any C++ type but only if it has been registered through the quat_traits template.
 When objects are returned by value their type is deduced either by the deduce_quat template (for unary functions) or the deduce_quat2 template (for binary functions).
 The type of scalar arguments is deduced independently from the type of the quaternion argument, so they are not required to match. Scalar arguments must convert implicitly to the quaternion scalar type.
See also: Boost QVM | Synopsis
Copyright (c) 2008-2016 by Emil Dotchevski and Reverge Studios, Inc.
Distributed under the Boost Software License, Version 1.0.
