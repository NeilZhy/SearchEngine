<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN'
'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>
	
	quaternion, vector and matrix types - 1.65.0
	
  
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
This is the documentation for an old version of Boost.
                Click here to view this page for the latest version.
QVM: Quaternions, Vectors, Matrices
Quaternion, Vector and Matrix Types
include <boost/qvm/quat.hpp> 
include <boost/qvm/vec.hpp> 
include <boost/qvm/mat.hpp> 
namespace boost
{
    namespace qvm
    {
        //*** Quaternion, vector and matrix types ***
        
        template <class T>
        struct quat
        {
            T a[4];
        
            template <class R>
            operator R() const
            {
                R r;
                assign(r,*this);
                return r;
            }
        };
        
        template <class Quaternion>
        struct quat_traits;
        
        template <class T>
        struct quat_traits< quat<T> >
        {
            typedef T scalar_type;
        
            template <int I> static scalar_type read_element( quat<T> const & x ) { return x.a[I]; }
            template <int I> static scalar_type & write_element( quat<T> & x ) { return x.a[I]; }
        };        
        
        template <class T,int Dim>
        struct vec
        {
            T a[Dim];
        
            template <class R>
            operator R() const
            {
                R r;
                assign(r,*this);
                return r;
            }
        };
        
        template <class Vector>
        struct vec_traits;
        
        template <class T,int Dim>
        struct vec_traits< vec<T,Dim> >
        {
            typedef T scalar_type;
            static int const dim=Dim;
        
            template <int I> static scalar_type read_element( vec<T,Dim> const & x ) { return x.a[I]; }
            template <int I> static scalar_type & write_element( vec<T,Dim> & x ) { return x.a[I]; }
        
            static scalar_type read_element_idx( int i, vec<T,Dim> const & x ) { return x.a[i]; }
            static scalar_type & write_element_idx( int i, vec<T,Dim> & x ) { return x.a[i]; }
        };        
        
        template <class T,int Rows,int Cols>
        struct mat
        {
            T a[Rows][Cols];
        
            template <class R>
            operator R() const
                {
                R r;
                assign(r,*this);
                return r;
                }
        };
        
        template <class Matrix>
        struct mat_traits;
        
        template <class T,int Rows,int Cols>
        struct mat_traits< mat<T,Rows,Cols> >
        {
            typedef T scalar_type;
            static int const rows=Rows;
            static int const cols=Cols;
        
            template <int Row,int Col> static scalar_type read_element( mat<T,Rows,Cols> const & x ) { return x.a[Row][Col]; }
            template <int Row,int Col> static scalar_type & write_element( mat<T,Rows,Cols> & x ) { return x.a[Row][Col]; }
        
            static scalar_type read_element_idx( int row, int col, mat<T,Rows,Cols> const & x ) { return x.a[row][col]; }
            static scalar_type & write_element_idx( int row, int col, mat<T,Rows,Cols> & x ) { return x.a[row][col]; }
        };
    }
}
See also: Boost QVM | Synopsis
Copyright (c) 2008-2016 by Emil Dotchevski and Reverge Studios, Inc.
Distributed under the Boost Software License, Version 1.0.
