<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
Chapter 6. Boost.Atomic - 1.65.0
  
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
This is the documentation for an old version of Boost.
                Click here to view this page for the latest version.
Chapter 6. Boost.Atomic
Helge Bahmann
Andrey Semashev
Copyright  2011 Helge Bahmann
Copyright  2012 Tim Blechmann
Copyright  2013 Andrey Semashev
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      
Table of Contents
Introduction
Presenting
      Boost.Atomic
Purpose
Thread coordination using Boost.Atomic
Enforcing happens-before
      through mutual exclusion
happens-before
      through release and acquire
Fences
happens-before
      through release and consume
Sequential consistency
Programming interfaces
Configuration and building
Memory order
Atomic objects
Fences
Feature testing macros
Usage examples
Reference
      counting
Spinlock
Singleton with
      double-checked locking pattern
Wait-free
      ring buffer
Wait-free multi-producer
      queue
Limitations
Porting
Unit tests
Tested compilers
Acknowledgements
Introduction
Presenting
      Boost.Atomic
Purpose
Presenting
      Boost.Atomic
        Boost.Atomic is a library that provides
        atomic data types and operations on these data types,
        as well as memory ordering constraints required for coordinating multiple
        threads through atomic variables. It implements the interface as defined
        by the C++11 standard, but makes this feature available for platforms lacking
        system/compiler support for this particular C++11 feature.
      
        Users of this library should already be familiar with concurrency in general,
        as well as elementary concepts such as "mutual exclusion".
      
        The implementation makes use of processor-specific instructions where possible
        (via inline assembler, platform libraries or compiler intrinsics), and falls
        back to "emulating" atomic operations through locking.
      
Purpose
        Operations on "ordinary" variables are not guaranteed to be atomic.
        This means that with int n=0 initially, two threads concurrently
        executing
      
void function()
{
  n ++;
}
        might result in n==1 instead of 2: Each thread will read
        the old value into a processor register, increment it and write the result
        back. Both threads may therefore write 1, unaware that
        the other thread is doing likewise.
      
        Declaring atomic<int> n=0 instead, the same operation
        on this variable will always result in n==2 as each operation
        on this variable is atomic: This means that each operation
        behaves as if it were strictly sequentialized with respect to the other.
      
        Atomic variables are useful for two purposes:
      
            as a means for coordinating multiple threads via custom coordination
            protocols
          
            as faster alternatives to "locked" access to simple variables
          
        Take a look at the examples
        section for common patterns.
      
Last revised: August 19, 2017 at 16:59:35 GMT
