<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
Chapter 9. Boost.Container - 1.65.0
  
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
This is the documentation for an old version of Boost.
                Click here to view this page for the latest version.
Chapter 9. Boost.Container
Ion Gaztanaga
Copyright  2009-2015 Ion Gaztanaga
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      
Table of Contents
Introduction
Building
      Boost.Container
Tested compilers
Main features
Efficient insertion
Containers
      of Incomplete Types
SCARY iterators
Other features
Boost.Container and C++ exceptions
Non-standard containers
stable_vector
flat_(multi)map/set
      associative containers
slist
static_vector
small_vector
Extended functionality
Default
      initialization for vector-like containers
Ordered
      range insertion for associative containers (ordered_unique_range,
      ordered_range) 
Configurable
      tree-based associative ordered containers
Constant-time
      range splice for (s)list
Extended
      allocators
Polymorphic
      Memory Resources 
C++11/C++14 Conformance
Move and Emplace
Stateful
      allocators
Scoped
      allocators
Insertion
      hints in associative containers and preserving insertion ordering for elements
      with equivalent keys
Initializer
      lists
Null Forward
      Iterators
forward_list<T>
vector vs. std::vector
      exception guarantees
Parameter
      taken by const reference that can be changed
vector<bool> specialization
Non-standard
      value initialization using std::memset
Known Issues
Move
      emulation limitations in C++03 compilers
History and reasons to use
    Boost.Container
Boost.Container
      history
Why
      Boost.Container?
Indexes
Class Index
Typedef Index
Function Index
Boost.Container Header Reference
Header <boost/container/adaptive_pool.hpp>
Header <boost/container/allocator.hpp>
Header <boost/container/allocator_traits.hpp>
Header <boost/container/container_fwd.hpp>
Header <boost/container/deque.hpp>
Header <boost/container/pmr/deque.hpp>
Header <boost/container/flat_map.hpp>
Header <boost/container/pmr/flat_map.hpp>
Header <boost/container/flat_set.hpp>
Header <boost/container/pmr/flat_set.hpp>
Header <boost/container/list.hpp>
Header <boost/container/pmr/list.hpp>
Header <boost/container/map.hpp>
Header <boost/container/pmr/map.hpp>
Header <boost/container/new_allocator.hpp>
Header <boost/container/node_allocator.hpp>
Header <boost/container/node_handle.hpp>
Header <boost/container/options.hpp>
Header <boost/container/pmr/global_resource.hpp>
Header <boost/container/pmr/memory_resource.hpp>
Header <boost/container/pmr/monotonic_buffer_resource.hpp>
Header <boost/container/pmr/polymorphic_allocator.hpp>
Header <boost/container/pmr/pool_options.hpp>
Header <boost/container/pmr/resource_adaptor.hpp>
Header <boost/container/pmr/synchronized_pool_resource.hpp>
Header <boost/container/pmr/unsynchronized_pool_resource.hpp>
Header <boost/container/scoped_allocator.hpp>
Header <boost/container/scoped_allocator_fwd.hpp>
Header <boost/container/set.hpp>
Header <boost/container/pmr/set.hpp>
Header <boost/container/slist.hpp>
Header <boost/container/pmr/slist.hpp>
Header <boost/container/small_vector.hpp>
Header <boost/container/pmr/small_vector.hpp>
Header <boost/container/stable_vector.hpp>
Header <boost/container/pmr/stable_vector.hpp>
Header <boost/container/static_vector.hpp>
Header <boost/container/string.hpp>
Header <boost/container/pmr/string.hpp>
Header <boost/container/throw_exception.hpp>
Header <boost/container/uses_allocator.hpp>
Header <boost/container/uses_allocator_fwd.hpp>
Header <boost/container/vector.hpp>
Header <boost/container/pmr/vector.hpp>
Acknowledgements, notes
    and links
Release Notes
Boost
      1.65 Release
Boost
      1.64 Release
Boost
      1.63 Release
Boost
      1.62 Release
Boost
      1.61 Release
Boost
      1.60 Release
Boost
      1.59 Release
Boost
      1.58 Release
Boost
      1.57 Release
Boost
      1.56 Release
Boost
      1.55 Release
Boost
      1.54 Release
Boost
      1.53 Release
Boost
      1.52 Release
Boost
      1.51 Release
Boost
      1.50 Release
Boost
      1.49 Release
Boost
      1.48 Release
Introduction
Building
      Boost.Container
Tested compilers
      Boost.Container library implements several
      well-known containers, including STL containers. The aim of the library is
      to offers advanced features not present in standard containers or to offer
      the latest standard draft features for compilers that don't comply with the
      latest C++ standard.
    
      In short, what does Boost.Container offer?
    
          Move semantics are implemented, including move emulation for pre-C++11
          compilers.
        
          New advanced features (e.g. placement insertion, recursive containers)
          are present.
        
          Containers support stateful allocators and are compatible with Boost.Interprocess (they can be safely placed in
          shared memory).
        
          The library offers new useful containers:
          
                flat_map,
                flat_set,
                flat_multimap
                and flat_multiset:
                drop-in replacements for standard associative containers but more
                memory friendly and with faster searches.
              
                stable_vector:
                a std::list and std::vector hybrid container: vector-like random-access
                iterators and list-like iterator stability in insertions and erasures.
              
                slist: the classic
                pre-standard singly linked list implementation offering constant-time
                size().
                Note that C++11 forward_list
                has no size().
              
        
Building
      Boost.Container
        There is no need to compile Boost.Container,
        since it's a header-only library, just include your Boost header directory
        in your compiler include path except if you use:
      
            Extended
            Allocators
          
            Some Polymorphic
            Memory Resources classes.
          
        Those exceptions are are implemented as a separately compiled library, so
        in those cases you must install binaries in a location that can be found
        by your linker. If you followed the Boost
        Getting Started instructions, that's already been done for you.
      
Tested compilers
        Boost.Container requires a decent C++98
        compatibility. Some compilers known to work are:
      
            Visual C++ >= 7.1.
          
            GCC >= 4.1.
          
            Intel C++ >= 9.0
          
Last revised: August 19, 2017 at 16:58:59 GMT
