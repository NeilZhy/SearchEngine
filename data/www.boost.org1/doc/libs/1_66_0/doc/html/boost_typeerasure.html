<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
Chapter 40. Boost.TypeErasure - 1.66.0
  
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
This is the documentation for an old version of Boost.
                Click here to view this page for the latest version.
Chapter 40. Boost.TypeErasure
Steven Watanabe
Copyright  2011-2013 Steven Watanabe
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      
Table of Contents
Introduction
How to read this documentation
Basic Usage
Composing Concepts
Functions with Multiple Arguments
Concepts in Depth
Defining Custom Concepts
Overloading
Concept Maps
Associated Types
Using Any
Construction
Conversions
References
Syntax Limitations
Examples
A polymorphic
      range formatter
A type-safe printf
Boost.Function
      with multiple signatures
Concept Definitions
Predefined Concepts
Reference
Header <boost/type_erasure/any.hpp>
Header <boost/type_erasure/any_cast.hpp>
Header <boost/type_erasure/binding.hpp>
Header <boost/type_erasure/binding_of.hpp>
Header <boost/type_erasure/builtin.hpp>
Header <boost/type_erasure/call.hpp>
Header <boost/type_erasure/callable.hpp>
Header <boost/type_erasure/check_match.hpp>
Header <boost/type_erasure/concept_interface.hpp>
Header <boost/type_erasure/concept_of.hpp>
Header <boost/type_erasure/config.hpp>
Header <boost/type_erasure/constructible.hpp>
Header <boost/type_erasure/deduced.hpp>
Header <boost/type_erasure/derived.hpp>
Header <boost/type_erasure/dynamic_any_cast.hpp>
Header <boost/type_erasure/dynamic_binding.hpp>
Header <boost/type_erasure/exception.hpp>
Header <boost/type_erasure/free.hpp>
Header <boost/type_erasure/is_empty.hpp>
Header <boost/type_erasure/is_placeholder.hpp>
Header <boost/type_erasure/is_subconcept.hpp>
Header <boost/type_erasure/iterator.hpp>
Header <boost/type_erasure/member.hpp>
Header <boost/type_erasure/operators.hpp>
Header <boost/type_erasure/param.hpp>
Header <boost/type_erasure/placeholder.hpp>
Header <boost/type_erasure/placeholder_of.hpp>
Header <boost/type_erasure/rebind_any.hpp>
Header <boost/type_erasure/register_binding.hpp>
Header <boost/type_erasure/relaxed.hpp>
Header <boost/type_erasure/require_match.hpp>
Header <boost/type_erasure/same_type.hpp>
Header <boost/type_erasure/static_binding.hpp>
Header <boost/type_erasure/tuple.hpp>
Header <boost/type_erasure/typeid_of.hpp>
Rationale
Why
      do I have to specify the presence of a destructor explicitly?
Why
      non-member functions?
Why are the
      placeholders called _a, _b and not _1
      _2
Why not use boost::ref
      for references?
Future Work
Acknowledgements
Related Work
Introduction
      The Boost.TypeErasure library provides runtime polymorphism in C++ that is
      more flexible than that provided by the core language.
    
      C++ has two distinct kinds of polymorphism, virtual functions and templates,
      each of which has its own advantages and disadvantages.
    
          Virtual functions are not resolved until runtime, while templates are always
          resolved at compile time. If your types can vary at runtime (for example,
          if they depend on user input), then static polymorphism with templates
          doesn't help much.
        
          Virtual functions can be used with separate compilation. The body of a
          template has to be available in every translation unit in which it is used,
          slowing down compiles and increasing rebuilds.
        
          Virtual functions automatically make the requirements on the arguments
          explicit. Templates are only checked when they're instantiated, requiring
          extra work in testing, assertions, and documentation.
        
          The compiler creates a new copy of each function template every time it
          is instantiated. This allows better optimization, because the compiler
          knows everything statically, but it also causes a significant increase
          of binary sizes.
        
          Templates support Value semantics. Objects that "behave like an int"
          and are not shared are easier to reason about. To use virtual functions,
          on the other hand, you have to use (smart) pointers or references.
        
          Template libraries can allow third-party types to be adapted non-intrusively
          for seamless interoperability. With virtual functions, you have to create
          a wrapper that inherits from the base class.
        
          Templates can handle constraints involving multiple types. For example,
          std::for_each takes an iterator range and a function that can be called
          on the elements of the range. Virtual functions aren't really able to express
          such constraints.
        
      The Boost.TypeErasure library combines the superior abstraction capabilities
      of templates, with the runtime flexibility of virtual functions.
    
      Boost includes several special cases of this kind of polymorphism:
    
          boost::any for CopyConstructible types.
        
          boost::function for objects that can be called
          like functions.
        
          Boost.Range provides any_iterator.
        
      Boost.TypeErasure generalizes this to support arbitrary requirements and provides
      a predefined set of common concepts
    
Last revised: December 05, 2017 at 23:51:31 GMT
