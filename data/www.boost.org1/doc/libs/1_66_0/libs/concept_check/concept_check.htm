<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  
  
  Concept Check Library - 1.66.0
  
  
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
This is the documentation for an old version of Boost.
                Click here to view this page for the latest version.
  
  The Boost Concept Check Library (BCCL)
  
    The Concept Check library allows one to add explicit statement and
    checking of concepts in the style
    of the proposed
    C++ language extension.
  
  Synopsis
  Generic programming in C++ is characterized by the use of template
  parameters to represent abstract data types (or “concepts”). However, the
  C++ language itself does not provide a mechanism for the writer of a class
  or function template to explicitly state the concept that the user-supplied
  template argument should model (or conform to). Template parameters are
  commonly named after the concept they're required to model as a hint to the
  user, and to make the concept requirements explicit in code. However, the
  compiler doesn't treat these special names specially: a parameter named
  RandomAccessIterator is no different to the compiler than one
  named T. Furthermore,
  
    Compiler error messages resulting from incorrect template arguments
    can be particularly difficult to decipher. Often times the error does not
    point to the location of the template call-site, but instead exposes the
    internals of the template, which the user should never have to see.
    Without checking from the compiler, the documented requirements are
    oftentimes vague, incorrect, or nonexistent, so a user cannot know
    exactly what kind of arguments are expected.
    The documented concept requirements may not fully cover the
    needs of the actual template, meaning the user could get a compiler error
    even though the supplied template arguments meet the documented
    requirements.
    The documented concept requirements may be too stringent, requiring
    more than is really needed by the template.
    Concept names in code may drift out-of-sync with the documented
    requirements.
  The Boost Concept Checking Library provides:
  
    A mechanism for inserting compile-time checks on template parameters
    at their point of use.
    A framework for specifying concept requirements through concept
    checking classes.
    A mechanism for verifying that concept requirements cover the
    template.
    A suite of concept checking classes and archetype classes that match
    the concept requirements in the C++ Standard Library.
    An alternative to the use of traits classes for accessing associated
    types that mirrors the syntax proposed for the next C++ standard.
  The mechanisms use standard C++ and introduce no run-time overhead.
  The main cost of using the mechanism is in compile-time.
  Every programmer writing class or function templates ought to
  make concept checking a normal part of their code writing routine.
  A concept check should be inserted for each template parameter in a
  component's public interface. If the concept is one of the ones from the
  Standard Library, then simply use the matching concept checking class in
  the BCCL. If not, then write a new concept checking class - after all, they
  are typically only a few lines long. For new concepts, a matching archetype
  class should also be created, which is a minimal skeleton-implementation of
  the concept
  The documentation is organized into the following sections.
  
    Introduction
    Motivating Example
    History
    Publications
    Acknowledgements
    Using Concept Checks
    Creating Concept Checking
    Classes
    Concept Covering and
    Archetypes
    Programming With Concepts
    Implementation
    Reference
  
  Jeremy Siek contributed this
  library. Beman Dawes managed
  the formal review. Dave
  Abrahams contributed a rewrite that updated syntax to be more
  compatible with proposed syntax for concept support the C++ core
  language.
  IntroductionA
  concept is a set of requirements (valid expressions, associated
  types, semantic invariants, complexity guarantees, etc.) that a type must
  fulfill to be correctly used as arguments in a call to a generic algorithm.
  In C++, concepts are represented by formal template parameters to function
  templates (generic algorithms). However, C++ has no explicit mechanism for
  representing concepts—template parameters are merely placeholders. By
  convention, these parameters are given names corresponding to the concept
  that is required, but a C++ compiler does not enforce compliance to the
  concept when the template parameter is bound to an actual type.
  Naturally, if a generic algorithm is invoked with a type that does not
  fulfill at least the syntactic requirements of the concept, a compile-time
  error will occur. However, this error will not per se reflect the
  fact that the type did not meet all of the requirements of the concept.
  Rather, the error may occur deep inside the instantiation hierarchy at the
  point where an expression is not valid for the type, or where a presumed
  associated type is not available. The resulting error messages are largely
  uninformative and basically impenetrable.
  What is required is a mechanism for enforcing
  “concept safety” at (or close to) the point
  of instantiation. The Boost Concept Checking Library uses some standard C++
  constructs to enforce early concept compliance and that provides more
  informative error messages upon non-compliance.
  Note that this technique only addresses the syntactic requirements of
  concepts (the valid expressions and associated types). We do not address
  the semantic invariants or complexity guarantees, which are also part of
  concept requirements..
  Motivating
  Example
  We present a simple example to illustrate incorrect usage of a template
  library and the resulting error messages. In the code below, the generic
  std::stable_sort() algorithm from the Standard Template Library
  (STL)[3, 4,5] is applied to a linked
  list.
  
  bad_error_eg.cpp:
1 #include <vector>
2 #include <complex>
3 #include <algorithm>
4 
5 int main()
6 {
7     std::vector<std::complex<float> > v;
8     std::stable_sort(v.begin(), v.end());
9 }
  Here, the std::stable_sort() algorithm is prototyped as
  follows:
  
  template <class RandomAccessIterator>
  void stable_sort(RandomAccessIterator first, RandomAccessIterator last);
  Attempting to compile this code with Gnu C++ produces the following
  compiler error:
  
/usr/include/c++/4.1.2/bits/stl_algo.h: In function ‘void std::
  __insertion_sort(_RandomAccessIterator, _RandomAccessIterator) [with 
  _RandomAccessIterator = __gnu_cxx::__normal_iterator<std::complex<float
  >*, std::vector<std::complex<float>, std::allocator<std::complex<
  float> > > >]’:
/usr/include/c++/4.1.2/bits/stl_algo.h:3066:   instantiated from ‘void 
  std::__inplace_stable_sort(_RandomAccessIterator, 
  _RandomAccessIterator) [with _RandomAccessIterator = __gnu_cxx::
  __normal_iterator<std::complex<float>*, std::vector<std::complex<
  float>, std::allocator<std::complex<float> > > >]’
/usr/include/c++/4.1.2/bits/stl_algo.h:3776:   instantiated from ‘void 
  std::stable_sort(_RandomAccessIterator, _RandomAccessIterator) [with 
  _RandomAccessIterator = __gnu_cxx::__normal_iterator<std::complex<float
  >*, std::vector<std::complex<float>, std::allocator<std::complex<
  float> > > >]’
bad_error_eg.cpp:8:   instantiated from here
/usr/include/c++/4.1.2/bits/stl_algo.h:2277: error: no match for 
  ‘operator<’ in ‘__val < __first. __gnu_cxx::__normal_iterator<
  _Iterator, _Container>::operator* [with _Iterator = std::complex<float
  >*, _Container = std::vector<std::complex<float>, std::allocator<
  std::complex<float> > >]()’
  In this case, the fundamental error is
  that std:complex<float> does not model the LessThanComparable
  concept.  Unfortunately, there is nothing in the error message to
  indicate that to the user.
  The error may be obvious to a C++ programmer having enough
  experience with template libraries, but there are several reasons
  why this message could be hard for the uninitiated to
  understand:
  
    There is no textual correlation between the error message and the
    documented requirements for std::stable_sort() and for LessThanComparable.
    The error message is overly long, listing functions internal
    to the STL (e.g. __insertion_sort) that the user
    does not (and should not!) know or care about.
    With so many internal library functions listed in the error message,
    the programmer could easily infer that the problem is in the library,
    rather than in his or her own code.
  
  The following is an example of what we might expect from a more
  informative message (and is in fact what the Boost Concept Checking Library
  produces):
  
boost/concept_check.hpp: In destructor ‘boost::LessThanComparable<TT>::~
  LessThanComparable() [with TT = std::complex<float>]’:
boost/concept/detail/general.hpp:29:   instantiated from ‘static void boost::
  concepts::requirement<Model>::failed() [with Model = boost::
  LessThanComparable<std::complex<float> >]’
boost/concept/requires.hpp:30:   instantiated from ‘boost::_requires_<void
  (*)(boost::LessThanComparable<std::complex<float> >)>’
bad_error_eg.cpp:8:   instantiated from here
boost/concept_check.hpp:236: error: no match for ‘operator<’ in ‘((boost::
  LessThanComparable<std::complex<float> >*)this)->boost::
  LessThanComparable<std::complex<float> >::a < ((boost::
  LessThanComparable<std::complex<float> >*)this)->boost::
  LessThanComparable<std::complex<float> >::b’
  This message rectifies several of the shortcomings of the standard error
  messages.
  
    The message refers explicitly to concepts that the user can look up
    in the STL documentation (LessThanComparable).
    The error message is now much shorter and does not reveal
    internal STL functions, nor indeed does it even point
    to std::stable_sort.
    The presence of concept_check.hpp in the error message
    alerts the user to the fact that the error lies in the user code and not
    in the library implementation.
  
  History
  The first version of this concept checking system was developed
  by Jeremy Siek while working at SGI in their C++ compiler and
  library group. That version is now part of the SGI STL
  distribution. The system originally introduced as the boost concept
  checking library differs from concept checking in the SGI STL in
  that the definition of concept checking classes was greatly
  simplified, at the price of less helpful verbiage in the error
  messages. In 2006 the system was rewritten (preserving backward
  compatibility) by Dave Abrahams to be easier to use, more similar to
  the proposed concept support the C++ core language, and to give
  better error messages.
  Publications
  
    C++ Template Workshop
    2000, Concept Checking
  
  AcknowledgementsThe idea to use function
  pointers to cause instantiation is due to Alexander Stepanov. We are not sure
  of the origin of the idea to use expressions to do up-front checking of
  templates, but it did appear in D&E[ 2]. Thanks to Matt
  Austern for his excellent documentation and organization of the STL
  concepts, upon which these concept checks are based. Thanks to Boost
  members for helpful comments and reviews.
  Next: Using Concept
  Checks
  
  
    
      Copyright  2000
      Jeremy Siek(jsiek@osl.iu.edu) Andrew
      Lumsdaine(lums@osl.iu.edu),
        2007 David Abrahams.
    
  
