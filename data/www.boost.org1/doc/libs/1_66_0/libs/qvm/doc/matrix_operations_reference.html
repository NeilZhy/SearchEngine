<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN'
'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>
	
	matrix operations - 1.66.0
	
  
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
This is the documentation for an old version of Boost.
                Click here to view this page for the latest version.
QVM: Quaternions, Vectors, Matrices
Matrix Operations
include <boost/qvm/mat_operations.hpp>
namespace boost
{
    namespace qvm
    {
        //*** Matrix operations ***
        
        //Only enabled if:
        //  is_mat<A>::value && is_mat<B>::value &&
        //  mat_traits<A>::rows==mat_traits<B>::rows &&
        //  mat_traits<A>::cols==mat_traits<B>::cols
        template <class A,class B>
        A & assign( A & a, B const & b );        
        
        //Only enabled if:
        //  is_mat<R>::value && is_mat<A>::value &&
        //  mat_traits<R>::rows==mat_traits<A>::rows &&
        //  mat_traits<R>::cols==mat_traits<A>::cols
        template <class R,class A>
        R convert_to( A const & a );        
        
        //Only enabled if:
        //  is_mat<A>::value && is_mat<B>::value &&
        //  mat_traits<A>::rows==mat_traits<B>::rows &&
        //  mat_traits<A>::cols==mat_traits<B>::cols
        template <class A,class B>
        A & operator-=( A & a, B const & b );        
        
        //Only enabled if: is_mat<A>::value
        template <class A>
        typename deduce_mat<A>::type
        operator-( A const & a );        
        
        //Only enabled if:
        //  is_mat<A>::value && is_mat<B>::value &&
        //  mat_traits<A>::rows==mat_traits<B>::rows &&
        //  mat_traits<A>::cols==mat_traits<B>::cols
        template <class A,class B>
        typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type
        operator-( A const & a, B const & b );        
        
        //Only enabled if:
        //  is_mat<A>::value && is_mat<B>::value &&
        //  mat_traits<A>::rows==mat_traits<B>::rows &&
        //  mat_traits<A>::cols==mat_traits<B>::cols
        template <class A,class B>
        A & operator+=( A & a, B const & b );        
        
        //Only enabled if:
        //  is_mat<A>::value && is_mat<B>::value &&
        //  mat_traits<A>::rows==mat_traits<B>::rows &&
        //  mat_traits<A>::cols==mat_traits<B>::cols
        template <class A,class B>
        typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<A>::cols>::type
        operator+( A const & a, B const & b );        
        
        //Only enabled if: is_mat<A>::value && is_scalar<B>::value
        template <class A,class B>
        A & operator/=( A & a, B b );        
        
        //Only enabled if: is_mat<A>::value && is_scalar<B>::value
        template <class A,class B>
        typename deduce_mat<A>::type
        operator/( A const & a, B b );        
        
        //Only enabled if:
        //  is_mat<A>::value && is_mat<B>::value &&
        //  mat_traits<A>::rows==mat_traits<A>::cols &&
        //  mat_traits<A>::rows==mat_traits<B>::rows &&
        //  mat_traits<A>::cols==mat_traits<B>::cols
        template <class A,class B>
        A & operator*=( A & a, B const & b );        
        
        //Only enabled if: is_mat<A>::value && is_scalar<B>::value
        template <class A,class B>
        A & operator*=( A & a, B b );        
        
        //Only enabled if:
        //  is_mat<A>::value && is_mat<B>::value &&
        //  mat_traits<A>::cols==mat_traits<B>::rows
        template <class A,class B>
        typename deduce_mat2<A,B,mat_traits<A>::rows,mat_traits<B>::cols>::type
        operator*( A const & a, B const & b );        
        
        //Only enabled if: is_mat<A>::value && is_scalar<B>::value
        template <class A,class B>
        typename deduce_mat<A>::type
        operator*( A const & a, B b );        
        
        //Only enabled if: is_scalar<A>::value && is_mat<B>::value
        template <class A,class B>
        typename deduce_mat<B>::type
        operator*( A a, B const & b );        
        
        //Only enabled if:
        //  is_mat<A>::value && is_mat<B>::value &&
        //  mat_traits<A>::rows==mat_traits<B>::rows &&
        //  mat_traits<A>::cols==mat_traits<B>::cols
        template <class A,class B>
        bool operator==( A const & a, B const & b );        
        
        //Only enabled if:
        //  is_mat<A>::value && is_mat<B>::value &&
        //  mat_traits<A>::rows==mat_traits<B>::rows &&
        //  mat_traits<A>::cols==mat_traits<B>::cols
        template <class A,class B>
        bool operator!=( A const & a, B const & b );        
        
        //Only enabled if:
        //  is_mat<A>::value && is_mat<B>::value &&
        //  mat_traits<A>::rows==mat_traits<B>::rows &&
        //  mat_traits<A>::cols==mat_traits<B>::cols
        template <class A,class B,class Cmp>
        bool cmp( A const & a, B const & b, Cmp pred );        
        
        //Only enabled if:
        //  is_mat<A>::value && is_scalar<B>::value
        //  mat_traits<A>::rows==mat_traits<A>::cols
        
        template <class A,class B>
        typename deduce_mat<A>::type
        inverse( A const & a, B det );
        
        template <class A>
        typename deduce_mat<A>::type
        inverse( A const & a );        
        
        template <class T,int D>
        -unspecified-return-type- zero_mat();
        
        template <class T,int R,int C>
        -unspecified-return-type- zero_mat();        
        
        //Only enabled if:
        //  is_mat<A>::value
        template <class A>
        void set_zero( A & a );        
        
        template <class S,int D>
        -unspecified-return-type- identity_mat();        
        
        //Only enabled if:
        //  is_mat<A>::value &&
        //  mat_traits<A>::cols==mat_traits<A>::rows
        template <class A>
        void set_identity( A & a );        
        
        //Only enabled if:
        //  is_vec<A>::value && vec_traits<A>::dim==3
        template <int Dim,class A,class Angle>
        -unspecified-return-type
        rot_mat( A const & axis, Angle angle );        
        
        //Only enabled if:
        //  is_mat<A>::value && mat_traits<A>::rows>=3 &&
        //  mat_traits<A>::rows==mat_traits<A>::cols &&
        //  is_vec<B>::value && vec_traits<B>::dim==3
        template <class A>
        void set_rot( A & a, B const & axis, typename vec_traits<B>::scalar_type angle );        
        
        //Only enabled if:
        //  is_mat<A>::value && mat_traits<A>::rows>=3 &&
        //  mat_traits<A>::rows==mat_traits<A>::cols &&
        //  is_vec<B>::value && vec_traits<B>::dim==3
        template <class A,class B>
        void rotate( A & a, B const & axis, typename mat_traits<A>::scalar_type angle );        
        
        template <int Dim,class Angle>
        -unspecified-return-type- rotx_mat( Angle const & angle );        
        
        //Only enabled if:
        //  is_mat<A>::value && mat_traits<A>::rows>=3 &&
        //  mat_traits<A>::rows==mat_traits<A>::cols
        template <class A>
        void set_rotx( A & a, typename mat_traits<A>::scalar_type angle );        
        
        //Only enabled if:
        //  is_mat<A>::value && mat_traits<A>::rows>=3 &&
        //  mat_traits<A>::rows==mat_traits<A>::cols
        template <class A>
        void rotate_x( A & a, typename mat_traits<A>::scalar_type angle );        
        
        template <int Dim,class Angle>
        -unspecified-return-type- roty_mat( Angle const & angle );        
        
        //Only enabled if:
        //  is_mat<A>::value && mat_traits<A>::rows>=3 &&
        //  mat_traits<A>::rows==mat_traits<A>::cols
        template <class A>
        void set_roty( A & a, typename mat_traits<A>::scalar_type angle );        
        
        //Only enabled if:
        //  is_mat<A>::value && mat_traits<A>::rows>=3 &&
        //  mat_traits<A>::rows==mat_traits<A>::cols
        template <class A>
        void rotate_y( A & a, typename mat_traits<A>::scalar_type angle );        
        
        template <int Dim,class Angle>
        -unspecified-return-type- rotz_mat( Angle const & angle );        
        
        //Only enabled if:
        //  is_mat<A>::value && mat_traits<A>::rows>=3 &&
        //  mat_traits<A>::rows==mat_traits<A>::cols
        template <class A>
        void set_rotz( A & a, typename mat_traits<A>::scalar_type angle );        
        
        //Only enabled if:
        //  is_mat<A>::value && mat_traits<A>::rows>=3 &&
        //  mat_traits<A>::rows==mat_traits<A>::cols
        template <class A>
        void rotate_z( A & a, typename mat_traits<A>::scalar_type angle );        
        
        //Only enabled if:
        //  is_mat<A>::value && mat_traits<A>::rows==mat_traits<A>::cols
        template <class A>
        mat_traits<A>::scalar_type
        determinant( A const & a );        
        
        template <class T>
        -unspecified-return-type
        perspective_lh( T fov_y, T aspect, T zn, T zf );        
        
        template <class T>
        -unspecified-return-type
        perspective_rh( T fov_y, T aspect, T zn, T zf );        
        
        //Only enabled if: is_mat<A>::value
        template <class A>
        -unspecified-return-type- mref( A & a );        
        
        //Only enabled if: is_mat<A>::value
        template <class Scalar,class A>
        -unspecified-return_type- scalar_cast( A const & a );
    }
}
This is a list of all matrix operations implemented by Boost QVM -- click on functions for individual documentation. General notes:
 All functions use SFINAE/enable_if. They are available for any C++ type but only if it has been registered through the mat_traits template.
 When objects are returned by value their type is deduced either by the deduce_mat template (for unary functions) or the deduce_mat2 template (for binary functions).
 The type of scalar arguments is deduced independently from the type of the matrix argument, so they are not required to match. Scalar arguments must convert implicitly to the matrix scalar type.
See also: Boost QVM | Synopsis
Copyright (c) 2008-2016 by Emil Dotchevski and Reverge Studios, Inc.
Distributed under the Boost Software License, Version 1.0.
