<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
Chapter 38. Boost.TypeIndex 4.1 - 1.62.0
  
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
This is the documentation for an old version of Boost.
                Click here to view this page for the latest version.
Chapter 38. Boost.TypeIndex 4.1
Copyright  2012-2016 Antony Polukhin
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      
Table of Contents
Motivation
Getting started
How to use
Example
      with Boost.Any
Example
      with Boost.Variant
Configuring and building the library
How it works
Examples
Getting
      human readable and mangled type names
Storing
      information about a type in container 
Getting
      through the inheritance to receive a real type name 
Exact
      type matching: storing type with const, volatile and reference qualifiers
Table
      of raw_name() and pretty_name() outputs with and without RTTI 
C++14:
      Checking namespace at compile time 
C++14:
      Checking lexigraphical order of provided types 
Boost.TypeIndex Header Reference
Header <boost/type_index.hpp>
Header <boost/type_index/ctti_type_index.hpp>
Header <boost/type_index/stl_type_index.hpp>
Header <boost/type_index/type_index_facade.hpp>
Making a custom
    type_index
Basics
Getting
      type infos at runtime
Using
      new type infos all around the code
Space and Performance
Code bloat
RTTI emulation
    limitations
Define
      the BOOST_TYPE_INDEX_FUNCTION_SIGNATURE macro
Fixing
      pretty_name() output
Mixing
    sources with RTTI on and RTTI off
Acknowledgements
Motivation
      Sometimes getting and storing information about a type at runtime is required.
      For such cases a construction like &typeid(T) or C++11 class std::type_index
      is usually used, which is where problems start:
    
          typeid(T) and
          std::type_index require Run Time Type Info
          (RTTI)
        
          some implementations of typeid(T)
          erroneously do not strip const, volatile and references from type
        
          some compilers have bugs and do not correctly compare std::type_info
          objects across shared libraries
        
          only a few implementations of Standard Library currently provide std::type_index
        
          no easy way to store type info without stripping const, volatile and references
        
          no nice and portable way to get human readable type names
        
          no way to easily make your own type info class
        
      Boost.TypeIndex library was designed to work around all those issues.
    
Note
        T means type here. Think
        of it as of T in template <class T>
      
Last revised: September 21, 2016 at 14:37:38 GMT
