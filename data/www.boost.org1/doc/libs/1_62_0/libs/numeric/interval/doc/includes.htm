<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
  
  
  
  Headers Inclusion - 1.62.0
  
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
This is the documentation for an old version of Boost.
                Click here to view this page for the latest version.
  Headers Inclusion
  The easiest way to access to the library is by including the main
  header:
  
#include <boost/numeric/interval.hpp>
  This header will include almost all the other headers (except the ones
  listed as extensions). However, you may not want to access all the
  functionalities of the library. So this page stands as a reminder for the
  whole structure of the library.
  <boost/numeric/interval.hpp> is the only header to be
  located directly under boost/numeric; all the other headers
  are located in the subdirectory boost/numeric/interval. And
  each time this documentation will refer to
  interval/something.hpp, it is
  <boost/numeric/interval/something.hpp>.
  Please also note that all the following headers are independent and can
  easily be pre-compiled if necessary (for compilers which support
  pre-compiled headers of course).
  Function definitions
  The following headers contain the definition of the
  interval class and all the friendly functions and
  operators.
  interval/interval.hpp
  This header contains the definition and the declaration of the
  interval class. However, this class is templated and the
  default template parameters are not available by this header. In
  particular, this header does not provide the default specialization of the
  interval class for the floating-point types
  (interval<float>, interval<double>
  and interval<long double>). So, unless you use your own
  policies, this header is not really useful on its own.
  interval/utility.hpp
  In this header are all the functions that do not expect any arithmetic
  property from the base number type. It only expects the bounds to be
  ordered; but it should not surprise you since it is a requirement of the
  whole library. You will find in this header the definitions of access and
  related functions: lower, upper,
  checked_lower, checked_upper,
  median, width, widen. There are also
  the set-like functions: in, zero_in,
  empty, subset, proper_subset,
  overlap, singleton, equal,
  intersect, hull, bisect. Finally,
  abs, min, and max are defined.
  interval/arith.hpp
  Here are the binary operators +, -,
  *, / and the unary operator -.
  interval/arith2.hpp
  This header defines fmod, square,
  sqrt, pow, and root.
  interval/arith3.hpp
  The third arithmetic header: it provides the functions add,
  sub, mul, and div. The type of their
  arguments is the base number type.
  interval/transc.hpp
  It is the last of the headers with mathematical functions; it provides
  the following functions: cos, sin,
  tan, acos, asin, atan,
  cosh, sinh, tanh,
  acosh, asinh, atanh,
  exp, and log.
  Policies
  The following headers define some policies. They may be needed if you
  use the default policies.
  interval/rounded_arith.hpp
  This header defines the three provided rounding policies for the
  arithmetic functions: rounded_arith_std,
  rounded_arith_opp, rounded_arith_exact.
  interval/rounded_transc.hpp
  This header defines the three provided rounding policies for the
  transcendental functions: rounded_transc_std,
  rounded_transc_opp, rounded_transc_exact. It is
  separated from rounded_arith.hpp since the transcendental part
  of the rounding policy is probably less useful than the arithmetic
  part.
  interval/hw_rounding.hpp
  Here are full rounding policies for the basic floating-point types. The
  policies are processor-dependent; and to allow the user code to be
  portable, they only define the common subset of the hardware available
  functions, which are the arithmetic functions of the rounding policy.
  interval/checking.hpp
  This header provides the predefined checking policies:
  checking_base, checking_no_empty,
  checking_no_nan, checking_catch_nan,
  checking_strict.
  interval/policies.hpp
  Here are defined the helpers for manipulating policies. It contains
  policies (and so is needed for using default policies),
  change_rounding, change_checking,
  unprotect, etc.
  Comparisons
  interval/compare.hpp
  This header includes all the following headers. They provide some
  predefined comparison namespaces.
  interval/compare/certain.hpp
  Here is compare::certain.
  interval/compare/possible.hpp
  And here is its friend compare::possible.
  interval/compare/explicit.hpp
  The explicit comparison functions cerlt,
  posge, etc are defined in this header.
  interval/compare/lexicographic.hpp
  This header provides compare::lexicographic.
  interval/compare/set.hpp
  This header provides compare::set.
  Extensions
  The following headers are not included by interval.hpp and
  will usually provide not always desirable capabilities.
  interval/io.hpp
  Here are defined basic stream operators << and
  >>. They should only be used as a first approach and
  later be replaced by a customized version.
  interval/limits.hpp
  A specialization of std::numeric_limits adapted to the
  interval type.
  interval/compare/tribool.hpp
  This header provides a comparison namespace
  compare::tribool especially adapted to a tristate boolean.
  interval/ext/integer.hpp
  This header provides mixed operations between intervals and integers. It
  is done by converting the integer to the base number type. Because this
  comparison is not always correct (for a big int may not be
  exactly convertible to float), this header is not
  automatically included and the user should ensure that this behavior is
  compatible with what she wants to do (if it is only to multiply some
  intervals by 2, it probably is a good thing to include this header).
  interval/ext/x86_fast_rounding_control.hpp
  This header defines a new rounding policy allowing to workaround the
  precision problem of the x86 processors (and so speeding up the
  computations). However, it only is a partial solution and it shouldn't be
  used when there is a possibility of underflow or overflow.
  
  
  Revised 
  2006-12-24
  Copyright  2002 Guillaume Melquiond, Sylvain Pion, Herv
  Brnnimann, Polytechnic University
  Copyright  2003-2006 Guillaume Melquiond, ENS Lyon
  Distributed under the Boost Software License, Version 1.0. (See
  accompanying file LICENSE_1_0.txt
  or copy at http://www.boost.org/LICENSE_1_0.txt)
