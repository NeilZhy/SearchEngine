<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
  
  
  Boost Function Object Adapter Library - 1.62.0
  
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
This is the documentation for an old version of Boost.
                Click here to view this page for the latest version.
  
  Function Object Traits
  The header functional.hpp
  provides two traits class templates for functions and function objects:
  
    
      Type
      Contents
      Description
    
    
      
      template <typename T>
      struct unary_traits
      function_type
      The type of the function or function object itself
      (i.e., T).
    
    
      param_type
      The type that should be used to pass the function or
      function object as a parameter.
    
    
      result_type
      The type returned by the function or function
      object.
    
    
      argument_type
      The type of the argument to the function or function
      object.
    
    
      
      template <typename T>
      struct binary_traits
      function_type
      The type of the function or function object itself
      (i.e., T).
    
    
      param_type
      The type that should be used to pass the function or
      function object as a parameter.
    
    
      result_type
      The type returned by the function or function
      object.
    
    
      first_argument_type
      The type of the first argument to the function or
      function object.
    
    
      second_argument_type
      The type of the second argument to the function or
      function object.
    
  
  Usage
  unary_traits should be instantiated with either a function
  taking a single parameter, or an adaptable unary function object (i.e., a
  class derived from std::unary_function or one which provides the
  same typedefs). (See 20.3.1 in the C++ Standard.)
  binary_traits should be instantiated with either a function
  taking two parameters, or an adaptable binary function object (i.e., a
  class derived from std::binary_function or one which provides the
  same typedefs). (See 20.3.1 in the C++ Standard.)
  The most common usage of these templates is in function object adapters,
  thus allowing them to adapt plain functions as well as function objects.
  You can do this by wherever you would normally write, for example,
  
    
typename Operation::argument_type
  
  simply writing
  
    
typename boost::unary_traits<Operation>::argument_type
  
  instead.
  Additional Types Defined
  In addition to the standard result and argument typedefs, these traits
  templates define two additional types.
  function_type
  This is the type of the function or function object, and can be used in
  declarations such as
  
    
template <class Predicate>
class unary_negate : // ...
{
  // ...
  private:
    typename unary_traits<Predicate>::function_type pred;
};
  
  If this typedef were not provided, it would not be possible to declare
  pred in a way that would allow unary_negate to be
  instantiated with a function type (see the C++ Standard 14.3.1
  3).
  param_type
  This is a type suitable for passing the function or function object as a
  parameter to another function. For example,
  
    
template <class Predicate>
class unary_negate : // ...
{
  public:
    explicit unary_negate(typename unary_traits<Predicate>::param_type x)
        :
        pred(x)
    {}
    // ...
};
  
  Function objects are passed by reference to const; function pointers are
  passed by value.
  Limitations
  This library uses these traits within all function object adapters,
  theoretically rendering ptr_fun obsolete. However, third party
  adapters probably won't take advantage of this mechanism, and so
  ptr_fun may still be required. Accordingly, this library also
  provides improved versions of the standard function
  pointer adapters.
  These traits templates will also not work with compilers that fail to
  support partial specialisation of templates. With these compilers, the
  traits templates can only be instantiated with adaptable function objects,
  thus requiring ptr_fun to be used, even with the function object
  adapters in this library.
  
  
  Revised 
  02
  December, 2006
  Copyright  2000 Cadenza New Zealand Ltd.
  Distributed under the Boost Software License, Version 1.0. (See
  accompanying file LICENSE_1_0.txt or
  copy at http://www.boost.org/LICENSE_1_0.txt)
