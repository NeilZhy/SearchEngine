<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
Boost Getting Started on Windows - 1.67.0
  
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
 Getting Started on Windows
A note to Cygwin and MinGW users
If you plan to use your tools from the Windows command prompt,
you're in the right place.  If you plan to build from the Cygwin
bash shell, you're actually running on a POSIX platform and
should follow the instructions for getting started on Unix
variants.  Other command shells, such as MinGW's MSYS, are
not supported—they may or may not work.
Index
1   Get Boost
2   The Boost Distribution
3   Header-Only Libraries
4   Build a Simple Program Using Boost
4.1   Build From the Visual Studio IDE
4.2   Or, Build From the Command Prompt
4.3   Errors and Warnings
5   Prepare to Use a Boost Library Binary
5.1   Simplified Build From Source
5.2   Or, Build Binaries From Source
5.2.1   Install Boost.Build
5.2.2   Identify Your Toolset
5.2.3   Select a Build Directory
5.2.4   Invoke b2
5.3   Expected Build Output
5.4   In Case of Build Errors
6   Link Your Program to a Boost Library
6.1   Link From Within the Visual Studio IDE
6.2   Or, Link From the Command Prompt
6.3   Library Naming
6.4   Test Your Program
7   Conclusion and Further Resources
1   Get Boost
The most reliable way to get a copy of Boost is to
download boost_1_67_0.7z or boost_1_67_0.zip and unpack it to install a complete Boost
distribution.1
2   The Boost Distribution
This is a sketch of the resulting directory structure:
boost_1_67_0\ .................The “boost root directory”
   index.htm .........A copy of www.boost.org starts here
   boost\ .........................All Boost Header files
   lib\ .....................precompiled library binaries
   libs\ ............Tests, .cpps, docs, etc., by library
     index.html ........Library documentation starts here
     algorithm\
     any\
     array\
                     …more libraries…
   status\ .........................Boost-wide test suite
   tools\ ...........Utilities, e.g. Boost.Build, quickbook, bcp
   more\ ..........................Policy documents, etc.
   doc\ ...............A subset of all Boost library docs
Header Organization
The organization of Boost library headers isn't entirely uniform,
but most libraries follow a few patterns:
Some older libraries and most very small libraries place all
public headers directly into boost\.
Most libraries' public headers live in a subdirectory of
boost\, named after the library.  For example, you'll find
the Python library's def.hpp header in
boost\python\def.hpp.
Some libraries have an “aggregate header” in boost\ that
#includes all of the library's other headers.  For
example, Boost.Python's aggregate header is
boost\python.hpp.
Most libraries place private headers in a subdirectory called
detail\, or aux_\.  Don't expect to find
anything you can use in these directories.
It's important to note the following:
The path to the boost root directory (often C:\Program Files\boost\boost_1_67_0) is
sometimes referred to as $BOOST_ROOT in documentation and
mailing lists .
To compile anything in Boost, you need a directory containing
the boost\ subdirectory in your #include path.  Specific steps for setting up #include
paths in Microsoft Visual Studio follow later in this document;
if you use another IDE, please consult your product's
documentation for instructions.
Since all of Boost's header files have the .hpp extension,
and live in the boost\ subdirectory of the boost root, your
Boost #include directives will look like:
#include <boost/whatever.hpp>
or
#include "boost/whatever.hpp"
depending on your preference regarding the use of angle bracket
includes.  Even Windows users can (and, for
portability reasons, probably should) use forward slashes in
#include directives; your compiler doesn't care.
Don't be distracted by the doc\ subdirectory; it only
contains a subset of the Boost documentation.  Start with
libs\index.html if you're looking for the whole enchilada.
3   Header-Only Libraries
The first thing many people want to know is, “how do I build
Boost?”  The good news is that often, there's nothing to build.
Nothing to Build?
Most Boost libraries are header-only: they consist entirely
of header files containing templates and inline functions, and
require no separately-compiled library binaries or special
treatment when linking.
The only Boost libraries that must be built separately are:
Boost.Chrono
Boost.Context
Boost.Filesystem
Boost.GraphParallel
Boost.IOStreams
Boost.Locale
Boost.Log (see build documentation)
Boost.MPI
Boost.ProgramOptions
Boost.Python (see the Boost.Python build documentation
before building and installing it)
Boost.Regex
Boost.Serialization
Boost.Signals
Boost.System
Boost.Thread
Boost.Timer
Boost.Wave
A few libraries have optional separately-compiled binaries:
Boost.DateTime has a binary component that is only needed if
you're using its to_string/from_string or serialization
features, or if you're targeting Visual C++ 6.x or Borland.
Boost.Graph also has a binary component that is only needed if
you intend to parse GraphViz files.
Boost.Math has binary components for the TR1 and C99
cmath functions.
Boost.Random has a binary component which is only needed if
you're using random_device.
Boost.Test can be used in “header-only” or “separately compiled”
mode, although separate compilation is recommended for serious
use.
Boost.Exception provides non-intrusive implementation of
exception_ptr for 32-bit _MSC_VER==1310 and _MSC_VER==1400
which requires a separately-compiled binary. This is enabled by
#define BOOST_ENABLE_NON_INTRUSIVE_EXCEPTION_PTR.
4   Build a Simple Program Using Boost
To keep things simple, let's start by using a header-only library.
The following program reads a sequence of integers from standard
input, uses Boost.Lambda to multiply each number by three, and
writes them to standard output:
#include <boost/lambda/lambda.hpp>
#include <iostream>
#include <iterator>
#include <algorithm>
int main()
{
    using namespace boost::lambda;
    typedef std::istream_iterator<int> in;
    std::for_each(
        in(std::cin), in(), std::cout << (_1 * 3) << " " );
}
Copy the text of this program into a file called example.cpp.
Note
To build the examples in this guide, you can use an
Integrated Development Environment (IDE) like Visual Studio, or
you can issue commands from the command prompt.  Since every
IDE and compiler has different options and Microsoft's are by
far the dominant compilers on Windows, we only give specific
directions here for Visual Studio 2005 and .NET 2003 IDEs and
their respective command prompt compilers (using the command
prompt is a bit simpler).  If you are using another compiler or
IDE, it should be relatively easy to adapt these instructions to
your environment.
Command Prompt Basics
In Windows, a command-line tool is invoked by typing its name,
optionally followed by arguments, into a Command Prompt window
and pressing the Return (or Enter) key.
To open a generic Command Prompt, click the Start menu
button, click Run, type “cmd”, and then click OK.
All commands are executed within the context of a current
directory in the filesystem.  To set the current directory,
type:
cd path\to\some\directory
followed by Return.  For example,
cd C:\Program Files\boost\boost_1_67_0
Long commands can be continued across several lines by typing a
caret (^) at the end of all but the last line.  Some examples
on this page use that technique to save horizontal space.
4.1   Build From the Visual Studio IDE
From Visual Studio's File menu, select New > Project…
In the left-hand pane of the resulting New Project dialog,
select Visual C++ > Win32.
In the right-hand pane, select Win32 Console Application
(VS8.0) or Win32 Console Project (VS7.1).
In the name field, enter “example”
Right-click example in the Solution Explorer pane and
select Properties from the resulting pop-up menu
In Configuration Properties > C/C++ > General > Additional Include
Directories, enter the path to the Boost root directory, for example
C:\Program Files\boost\boost_1_67_0
In Configuration Properties > C/C++ > Precompiled Headers, change
Use Precompiled Header (/Yu) to Not Using Precompiled
Headers.2
Replace the contents of the example.cpp generated by the IDE
with the example code above.
From the Build menu, select Build Solution.
To test your application, hit the F5 key and type the following
into the resulting window, followed by the Return key:
1 2 3
Then hold down the control key and press "Z", followed by the
Return key.
skip to the next step
4.2   Or, Build From the Command Prompt
From your computer's Start menu, if you are a Visual
Studio 2005 user, select
All Programs > Microsoft Visual Studio 2005
> Visual Studio Tools > Visual Studio 2005 Command Prompt
or, if you're a Visual Studio .NET 2003 user, select
All Programs > Microsoft Visual Studio .NET 2003
> Visual Studio .NET Tools > Visual Studio .NET 2003 Command Prompt
to bring up a special command prompt window set up for the
Visual Studio compiler.  In that window, set the current
directory to a suitable location for creating some temporary
files and type the following command followed by the Return key:
cl /EHsc /I path\to\boost_1_67_0 path\to\example.cpp
To test the result, type:
echo 1 2 3 | example
4.3   Errors and Warnings
Don't be alarmed if you see compiler warnings originating in Boost
headers.  We try to eliminate them, but doing so isn't always
practical.4 Errors are another matter.  If you're
seeing compilation errors at this point in the tutorial, check to
be sure you've copied the example program correctly and that you've
correctly identified the Boost root directory.
5   Prepare to Use a Boost Library Binary
If you want to use any of the separately-compiled Boost libraries,
you'll need to acquire library binaries.
5.1   Simplified Build From Source
If you wish to build from source with Visual C++, you can use a
simple build procedure described in this section. Open the command prompt
and change your current directory to the Boost root directory. Then, type
the following commands:
bootstrap
.\b2
The first command prepares the Boost.Build system for use. The second
command invokes Boost.Build to build the separately-compiled Boost
libraries. Please consult the Boost.Build documentation for a list
of allowed options.
5.2   Or, Build Binaries From Source
If you're using an earlier version of Visual C++, or a compiler
from another vendor, you'll need to use Boost.Build to create your
own binaries.
5.2.1   Install Boost.Build
Boost.Build is a text-based system for developing, testing, and
installing software. First, you'll need to build and
install it. To do this:
Go to the directory tools\build\.
Run bootstrap.bat
Run b2 install --prefix=PREFIX where PREFIX is
the directory where you want Boost.Build to be installed
Add PREFIX\bin to your PATH environment variable.
5.2.2   Identify Your Toolset
First, find the toolset corresponding to your compiler in the
following table (an up-to-date list is always available in the
Boost.Build documentation).
Note
If you previously chose a toolset for the purposes of
building b2, you should assume it won't work and instead
choose newly from the table below.
Toolset
Name
Vendor
Notes
acc
Hewlett Packard
Only very recent versions are known to work well with Boost
borland
Borland
 
como
Comeau Computing
Using this toolset may require configuring another
toolset to act as its backend.
darwin
Apple Computer
Apple's version of the GCC toolchain with support for
Darwin and MacOS X features such as frameworks.
gcc
The Gnu Project
Includes support for Cygwin and MinGW compilers.
hp_cxx
Hewlett Packard
Targeted at the Tru64 operating system.
intel
Intel
 
msvc
Microsoft
 
sun
Oracle
Only very recent versions are known to work well with
Boost.  Note that the Oracle/Sun compiler has a large number
of options which effect binary compatibility: it is vital
that the libraries are built with the same options that your
appliction will use. In particular be aware that the default
standard library may not work well with Boost, unless you
are building for C++11. The particular compiler options you
need can be injected with the b2 command line options
cxxflags=``and ``linkflags=.  For example to build with
the Apache standard library in C++03 mode use
b2 cxxflags=-library=stdcxx4 linkflags=-library=stdcxx4.
vacpp
IBM
The VisualAge C++ compiler.
If you have multiple versions of a particular compiler installed,
you can append the version number to the toolset name, preceded by
a hyphen, e.g. intel-9.0 or
borland-5.4.3. On Windows, append a version
number even if you only have one version installed (unless you
are using the msvc or gcc toolsets, which have special version
detection code) or auto-linking will fail.
5.2.3   Select a Build Directory
Boost.Build will place all intermediate files it generates while
building into the build directory.  If your Boost root
directory is writable, this step isn't strictly necessary: by
default Boost.Build will create a bin.v2/ subdirectory for that
purpose in your current working directory.
5.2.4   Invoke b2
Change your current directory to the Boost root directory and
invoke b2 as follows:
b2 --build-dir=build-directory toolset=toolset-name --build-type=complete stage
For a complete description of these and other invocation options,
please see the Boost.Build documentation.
For example, your session might look like this:3
C:\WINDOWS> cd C:\Program Files\boost\boost_1_67_0
C:\Program Files\boost\boost_1_67_0> b2 ^
More? --build-dir="C:\Documents and Settings\dave\build-boost" ^
More? --build-type=complete msvc stage
Be sure to read this note about the appearance of ^,
More? and quotation marks (") in that line.
The option “--build-type=complete” causes Boost.Build to build
all supported variants of the libraries.  For instructions on how to
build only specific variants, please ask on the Boost.Build mailing
list.
Building the special stage target places Boost
library binaries in the stage\lib\ subdirectory of
the Boost tree.  To use a different directory pass the
--stagedir=directory option to b2.
Note
b2 is case-sensitive; it is important that all the
parts shown in bold type above be entirely lower-case.
For a description of other options you can pass when invoking
b2, type:
b2 --help
In particular, to limit the amount of time spent building, you may
be interested in:
reviewing the list of library names with --show-libraries
limiting which libraries get built with the --with-library-name or --without-library-name options
choosing a specific build variant by adding release or
debug to the command line.
Note
Boost.Build can produce a great deal of output, which can
make it easy to miss problems.  If you want to make sure
everything is went well, you might redirect the output into a
file by appending “>build.log 2>&1” to your command line.
5.3   Expected Build Output
During the process of building Boost libraries, you can expect to
see some messages printed on the console.  These may include
Notices about Boost library configuration—for example, the Regex
library outputs a message about ICU when built without Unicode
support, and the Python library may be skipped without error (but
with a notice) if you don't have Python installed.
Messages from the build tool that report the number of targets
that were built or skipped.  Don't be surprised if those numbers
don't make any sense to you; there are many targets per library.
Build action messages describing what the tool is doing, which
look something like:
toolset-name.c++ long/path/to/file/being/built
Compiler warnings.
5.4   In Case of Build Errors
The only error messages you see when building Boost—if any—should
be related to the IOStreams library's support of zip and bzip2
formats as described here.  Install the relevant development
packages for libz and libbz2 if you need those features.  Other
errors when building Boost libraries are cause for concern.
If it seems like the build system can't find your compiler and/or
linker, consider setting up a user-config.jam file as described
here.  If that isn't your problem or the user-config.jam file
doesn't work for you, please address questions about configuring Boost
for your compiler to the Boost.Build mailing list.
6   Link Your Program to a Boost Library
To demonstrate linking with a Boost binary library, we'll use the
following simple program that extracts the subject lines from
emails.  It uses the Boost.Regex library, which has a
separately-compiled binary component.
#include <boost/regex.hpp>
#include <iostream>
#include <string>
int main()
{
    std::string line;
    boost::regex pat( "^Subject: (Re: |Aw: )*(.*)" );
    while (std::cin)
    {
        std::getline(std::cin, line);
        boost::smatch matches;
        if (boost::regex_match(line, matches, pat))
            std::cout << matches[2] << std::endl;
    }
}
There are two main challenges associated with linking:
Tool configuration, e.g. choosing command-line options or IDE
build settings.
Identifying the library binary, among all the build variants,
whose compile configuration is compatible with the rest of your
project.
Auto-Linking
Most Windows compilers and linkers have so-called “auto-linking
support,” which eliminates the second challenge.  Special code in
Boost header files detects your compiler options and uses that
information to encode the name of the correct library into your
object files; the linker selects the library with that name from
the directories you've told it to search.
The GCC toolchains (Cygwin and MinGW) are notable exceptions;
GCC users should refer to the linking instructions for Unix
variant OSes for the appropriate command-line options to use.
6.1   Link From Within the Visual Studio IDE
Starting with the header-only example project we created
earlier:
Right-click example in the Solution Explorer pane and
select Properties from the resulting pop-up menu
In Configuration Properties > Linker > Additional Library
Directories, enter the path to the Boost binaries,
e.g. C:\Program Files\boost\boost_1_67_0\lib\.
From the Build menu, select Build Solution.
skip to the next step
6.2   Or, Link From the Command Prompt
For example, we can compile and link the above program from the
Visual C++ command-line by simply adding the bold text below to
the command line we used earlier, assuming your Boost binaries are
in C:\Program Files\boost\boost_1_67_0\lib:
cl /EHsc /I path\to\boost_1_67_0 example.cpp   ^
     /link /LIBPATH:C:\Program Files\boost\boost_1_67_0\lib
6.3   Library Naming
Note
If, like Visual C++, your compiler supports auto-linking,
you can probably skip to the next step.
In order to choose the right binary for your build configuration
you need to know how Boost binaries are named.  Each library
filename is composed of a common sequence of elements that describe
how it was built.  For example,
libboost_regex-vc71-mt-d-x86-1_34.lib can be broken down into the
following elements:
lib
Prefix: except on Microsoft Windows, every Boost library
name begins with this string.  On Windows, only ordinary static
libraries use the lib prefix; import libraries and DLLs do
not.5
boost_regex
Library name: all boost library filenames begin with boost_.
-vc71
Toolset tag: identifies the toolset and version used to build
the binary.
-mt
Threading tag: indicates that the library was
built with multithreading support enabled.  Libraries built
without multithreading support can be identified by the absence
of -mt.
-d
ABI tag: encodes details that affect the library's
interoperability with other compiled code.  For each such
feature, a single letter is added to the tag:
Key
Use this library when:
Boost.Build option
s
linking statically to the C++ standard library and compiler runtime support
libraries.
runtime-link=static
g
using debug versions of the standard and runtime support libraries.
runtime-debugging=on
y
using a special debug build of Python.
python-debugging=on
d
building a debug version of your code.6
variant=debug
p
using the STLPort standard library rather than the default one supplied with
your compiler.
stdlib=stlport
For example, if you build a debug version of your code for use
with debug versions of the static runtime library and the
STLPort standard library,
the tag would be: -sgdp.  If none of the above apply, the
ABI tag is ommitted.
-x86
Architecture and address model tag: in the first letter, encodes the architecture as follows:
Key
Architecture
Boost.Build option
x
x86-32, x86-64
architecture=x86
a
ARM
architecture=arm
i
IA-64
architecture=ia64
s
Sparc
architecture=sparc
m
MIPS/SGI
architecture=mips*
p
RS/6000 & PowerPC
architecture=power
The two digits following the letter encode the address model as follows:
Key
Address model
Boost.Build option
32
32 bit
address-model=32
64
64 bit
address-model=64
-1_34
Version tag: the full Boost release number, with periods
replaced by underscores. For example, version 1.31.1 would be
tagged as "-1_31_1".
.lib
Extension: determined according to the operating system's usual
convention.  On most unix-style platforms the extensions are
.a and .so for static libraries (archives) and shared
libraries, respectively.  On Windows, .dll indicates a shared
library and .lib indicates a
static or import library.  Where supported by toolsets on unix
variants, a full version extension is added (e.g. ".so.1.34") and
a symbolic link to the library file, named without the trailing
version number, will also be created.
6.4   Test Your Program
To test our subject extraction, we'll filter the following text
file.  Copy it out of your browser and save it as jayne.txt:
To: George Shmidlap
From: Rita Marlowe
Subject: Will Success Spoil Rock Hunter?
---
See subject.
Now, in a command prompt window, type:
path\to\compiled\example < path\to\jayne.txt
The program should respond with the email subject, “Will Success
Spoil Rock Hunter?”
7   Conclusion and Further Resources
This concludes your introduction to Boost and to integrating it
with your programs.  As you start using Boost in earnest, there are
surely a few additional points you'll wish we had covered.  One day
we may have a “Book 2 in the Getting Started series” that addresses
them.  Until then, we suggest you pursue the following resources.
If you can't find what you need, or there's anything we can do to
make this document clearer, please post it to the Boost Users'
mailing list.
Boost.Build reference manual
Boost Users' mailing list
Boost.Build mailing list
Index of all Boost library documentation
Onward
Good luck, and have fun!
the Boost Developers
[1]We recommend
downloading boost_1_67_0.7z and using 7-Zip to decompress
it.  We no longer recommend .zip files for Boost because they are twice
as large as the equivalent .7z files.  We don't recommend using Windows'
built-in decompression as it can be painfully slow for large archives.
[2]There's no problem using Boost with precompiled headers;
these instructions merely avoid precompiled headers because it
would require Visual Studio-specific changes to the source code
used in the examples.
[3]In this example, the caret character ^ is a
way of continuing the command on multiple lines, and must be the
final character used on the line to be continued (i.e. do
not follow it with spaces).  The command prompt responds with
More? to prompt for more input.  Feel free to omit the
carets and subsequent newlines; we used them so the example
would fit on a page of reasonable width.
The command prompt treats each bit of whitespace in the command
as an argument separator.  That means quotation marks (")
are required to keep text together whenever a single
command-line argument contains spaces, as in
--build-dir="C:\Documents_and_Settings\dave\build-boost"
Also, for example, you can't add spaces around the = sign as in
--build-dir_=_"C:\Documents and Settings\dave\build-boost"
[4]Remember that warnings are specific to each compiler
implementation.  The developer of a given Boost library might
not have access to your compiler.  Also, some warnings are
extremely difficult to eliminate in generic code, to the point
where it's not worth the trouble.  Finally, some compilers don't
have any source code mechanism for suppressing warnings.
[5]This convention distinguishes the static version of
a Boost library from the import library for an
identically-configured Boost DLL, which would otherwise have the
same name.
[6]These libraries were compiled without optimization
or inlining, with full debug symbols enabled, and without
NDEBUG #defined.  Although it's true that sometimes
these choices don't affect binary compatibility with other
compiled code, you can't count on that with Boost libraries.
