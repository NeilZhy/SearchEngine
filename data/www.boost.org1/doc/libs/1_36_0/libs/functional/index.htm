<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
  
  
  
  
  Boost Function Object Adapter Library - 1.36.0
  
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
This is the documentation for an old version of Boost.
                Click here to view this page for the latest version.
  
  Improved Function Object Adapters
  The header functional.hpp
  provides enhancements to the function object adapters specified in the C++
  Standard Library (sections 20.3.5, through to 20.3.8). The enhancements are
  principally possible due to two changes:
  
    We use the Boost call_traits templates to avoid the
    problem of references to references,
    and to improve the efficiency of parameter
    passing.
    We use two function object traits
    class templates to avoid the need for ptr_fun with the adapters in this library.
  
  Contents
  The header contains the following function and class templates:
  
    
      Function object
      traits
      unary_traits
      binary_traits
      Used to determine the types of function objects' and
      functions' arguments. Eliminate the necessity for
      ptr_fun.
    
    
      Negators
      unary_negate
      binary_negate
      not1
      not2
      Based on section 20.3.5 of the standard.
    
    
      Binders
      binder1st
      binder2nd
      bind1st
      bind2nd
      Based on section 20.3.6 of the standard.
    
    
      Adapters for pointers to
      functions
      pointer_to_unary_function
      pointer_to_binary_function
      ptr_fun
      Based on section 20.3.7 of the standard. Not required
      for use with this library since the binders and negators can adapt
      functions, but may be needed with third party adapters.
    
    
      Adapters for pointers to member
      functions
      mem_fun_t
      mem_fun1_t
      const_mem_fun_t
      const_mem_fun1_t
      mem_fun_ref_t
      mem_fun1_ref_t
      const_mem_fun_ref_t
      const_mem_fun1_ref_t
      mem_fun
      mem_fun_ref
      Based on section 20.3.8 of the standard.
    
  
  Usage
  Using these adapters should be pretty much the same as using the
  standard function object adapters; the only differences are that you need
  to write boost:: instead of std::, and that you will get
  fewer headaches.
  For example, suppose you had a Person class that contained a
  set_name function:
  
    
class Person
{
  public:
    void set_name(const std::string &name);
  // ...
};
  
  You could rename a bunch of people in a collection, c, by
  writing
  
    
std::for_each(c.begin(), c.end(), 
              boost::bind2nd(boost::mem_fun_ref(&Person::set_name), "Fred"));
  
  If the standard adapters had been used instead then this code would
  normally fail to compile, because set_name takes a reference
  argument. Refer to the comments in the binder
  documentation to explain why this is so.
  Compiler Compatibility
  The header and test program have been
  compiled with the following compilers:
  
    
      Compiler
      Comments
    
    
      Borland C++Builder 4 Update 2
      No known issues.
    
    
      Borland C++ 5.5
      No known issues.
    
    
      g++ 2.95.2
      No known issues.
    
    
      Microsoft Visual C++ Service Pack 3
      
        Compiler lacks partial specialisation, so this library offers little
        more than is provided by the standard adapters:
        
          The call_traits mechanism is unable to prevent
          references to references, and so the adapters in this library will
          be usable in fewer situations.
          The function_traits mechanism is unable to determine
          the argument and result types of functions, therefore
          ptr_fun continues to be required to adapt functions.
        
      
    
  
  Future Directions
  This library's primary focus is to solve the problem of references to
  references while maintaining as much compatibility as possible with the
  standard library. This allows you to use the techniques you read about in
  books and magazines with many of today's compilers.
  In the longer term, even better solutions are likely:
  
    Several Boost members are working on expression template libraries.
    These will allow a more natural syntax for combining and adapting
    functions. As this is a new technology, it may be some time before it has
    matured and is widely supported by major compilers but shows great
    promise. In the meantime, the functional.hpp library fills the gap.
    The Standard Committee has recognised the problem of references to
    references occurring during template instantiation and has moved to fix
    the standard (see the C++
    standard core language active issues list).
  
  Author
  Mark Rodgers
  Acknowledgements
  Thanks to John Maddock for
  suggesting the mechanism that allowed the function objects traits to work
  correctly. Jens Maurer provided
  invaluable feedback during the formal review process.
  
  
  Revised 
  02
  December, 2006
  Copyright  2000 Cadenza New Zealand Ltd.
  Distributed under the Boost Software License, Version 1.0. (See
  accompanying file LICENSE_1_0.txt or
  copy at http://www.boost.org/LICENSE_1_0.txt)
