
Uuid Library - 1.61.0
  
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
This is the documentation for an old version of boost.
                Click here for the latest Boost documentation.
Uuid
Contents
    Introduction
    Configuration
    Examples
    
        Tagging
        POD Efficiencies
        Byte Extraction
    Reference
    
        boost/uuid/uuid.hpp
        
            Synopsis
            Size
            Iteration
            Nil uuid
            Variant
            Version
            Swap
            Operators
            Hash
        
        boost/uuid/uuid_generators.hpp
        
            Synopsis
        
        boost/uuid/nil_generator.hpp
        
            Synopsis
            Nil Generator
        
        boost/uuid/string_generator.hpp
        
            Synopsis
            String Generator
        
        boost/uuid/name_generator.hpp
        
            Synopsis
            Name Generator
        
        boost/uuid/random_generator.hpp
        
            Synopsis
            Random Generator
        
        boost/uuid/uuid_io.hpp
        
            Synopsis
            Stream Operators
            To String
        
        boost/uuid/uuid_serialize.hpp
        
            Synopsis
            Serialization
        
    
    Design notes
    History and Acknowledgements
Introduction
A UUID, or Universally unique identifier, is intended to uniquely identify
information in a distributed environment without significant central
coordination.  It can be used to tag objects with very short lifetimes, or 
to reliably identify very persistent objects across a network.
UUIDs have many applications.  Some examples follow:  Databases may use UUIDs 
to identify rows or records in order to ensure that they are unique across 
different databases, or for publication/subscription services.  Network messages
may be identified with a UUID to ensure that different parts of a message are put 
back together again.  Distributed computing may use UUIDs to identify a remote 
procedure call.  Transactions and classes involved in serialization may be
identified by UUIDs.  Microsoft's component object model (COM) uses UUIDs to 
distinguish different software component interfaces.  UUIDs are inserted into 
documents from Microsoft Office programs.  UUIDs identify audio or 
video streams in the Advanced Systems Format (ASF).  UUIDs are also a basis 
for OIDs (object identifiers), and URNs (uniform resource name).
An attractive feature of UUIDs when compared to alternatives is their relative 
small size, of 128-bits, or 16-bytes.  Another is that the creation of UUIDs 
does not require a centralized authority.
When UUIDs are generated by one of the defined
mechanisms, they are either guaranteed to be unique, different from all other
generated UUIDs (that is, it has never been generated before and it will
never be generated again), or it is extremely likely to be unique (depending
on the mechanism).
Configuration
The library does not require building or any special configuration to be used.
However, there are a few options that can be enabled by defining macros prior to
including library headers. These macros are summarized in the following table.
MacroDescription
BOOST_UUID_NO_SIMDIf defined, disables any optimizations for SIMD-enabled processors. Generic versions of algorithms will be used instead. This may result in suboptimal performance. By default, optimized algorithms are used, when the library is able to detect the availability of SIMD extensions at compile time.
BOOST_UUID_USE_SSE2If defined, enables optimizations for SSE2 exstensions available in modern x86 processors.
BOOST_UUID_USE_SSE3If defined, enables optimizations for SSE3 exstensions available in modern x86 processors.
BOOST_UUID_USE_SSE41If defined, enables optimizations for SSE4.1 exstensions available in modern x86 processors.
By default the library attempts to detect the availability of SIMD extensions in the target CPU at compile time and automatically defines the appropriate macros if succeeded. The BOOST_UUID_USE_SSE* macros can be defined by users, if auto-detection fails and it is known that the target CPU will have the extension. Do not enable these extensions unless you're certain that they will always be available on any machine that will run your program. The library performs no run time checks, so if an extension is missing, the program will likely crash. Note that enabling more advanced extensions implies that more basic ones are also available.
Examples
Tagging
// example of tagging an object with a uuid
// see boost/libs/uuid/test/test_tagging.cpp
#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>
class object
{
public:
    object()
        : tag(boost::uuids::random_generator()())
        , state(0)
    {}
    explicit object(int state)
        : tag(boost::uuids::random_generator()())
        , state(state)
    {}
    object(object const& rhs)
        : tag(rhs.tag)
        , state(rhs.state)
    {}
    bool operator==(object const& rhs) const {
        return tag == rhs.tag;
    }
    object& operator=(object const& rhs) {
        tag = rhs.tag;
        state = rhs.state;
    }
    int get_state() const { return state; }
    void set_state(int new_state) { state = new_state; }
private:
    boost::uuids::uuid tag;
    int state;
};
object o1(1);
object o2 = o1;
o2.set_state(2);
assert(o1 == o2);
object o3(3);
assert(o1 != o3);
assert(o2 != o3);
POD Efficiencies
This library implements a UUID as a POD allowing a UUID
to be used in the most efficient ways, including using memcpy, 
and aggregate initializers.  A drawback is that a POD can 
not have any constructors, and thus declaring a UUID will not 
initialize it to a value generated by one of the defined 
mechanisms.  But a class based on a UUID can be defined 
that does initialize itself to a value generated by one of 
the defined mechanisms.
Note that boost::is_pod is specialized for boost::uuids::uuid
and depends on Boost.TypeTraits.
Define BOOST_UUID_NO_TYPE_TRAITS before including boost/uuid/uuid.hpp
to remove the dependency on Boost.TypeTraits.
// example using memcpy and aggregate initializers
// example of a class uuid see boost/libs/uuid/test/test_uuid_class.cpp
#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>
{ // example using memcpy
    unsigned char uuid_data[16];
    // fill uuid_data
    boost::uuids::uuid u;
    memcpy(&u, uuid_data, 16);
}
{ // example using aggregate initializers
    boost::uuids::uuid u =
    { 0x12 ,0x34, 0x56, 0x78
    , 0x90, 0xab
    , 0xcd, 0xef
    , 0x12, 0x34
    , 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef
    };
}
// example of creating a uuid class that
// initializes the uuid in the constructor
// using a defined mechanism
class uuid_class : public boost::uuids::uuid
{
public:
    uuid_class()
        : boost::uuids::uuid(boost::uuids::random_generator()())
    {}
    explicit uuid_class(boost::uuids::uuid const& u)
        : boost::uuids::uuid(u)
    {}
    operator boost::uuids::uuid() {
        return static_cast<boost::uuids::uuid&>(*this);
    }
    operator boost::uuids::uuid() const {
        return static_cast<boost::uuids::uuid const&>(*this);
    }
};
uuid_class u1;
uuid_class u2;
assert(u1 != u2);
Byte Extraction
It is sometimes useful to get at the 16 bytes of a uuid directly.  
Typical use is as follows:
boost::uuids::uuid u;
std::vector<char> v(u.size());
std::copy(u.begin(), u.end(), v.begin());
Note: boost::uuids::uuid::size() always returns 16.
Reference
boost/uuid/uuid.hpp
Synopsis
namespace boost {
namespace uuids {
class uuid {
public:
    typedef uint8_t value_type;
    typedef uint8_t& reference;
    typedef uint8_t const& const_reference;
    typedef uint8_t* iterator;
    typedef uint8_t const* const_iterator;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
    static constexpr size_type static_size() noexcept;
    // iteration
    iterator begin() noexcept;
    iterator end() noexcept;
    const_iterator begin() const noexcept;
    const_iterator end() const noexcept;
    constexpr size_type size() const noexcept;
    bool is_nil() const noexcept;
    enum variant_type {
        variant_ncs, // NCS backward compatibility
        variant_rfc_4122, // defined in RFC 4122 document
        variant_microsoft, // Microsoft Corporation backward compatibility
        variant_future // future definition
    };
    variant_type variant() const noexcept;
    enum version_type {
        version_unknown = -1,
        version_time_based = 1,
        version_dce_security = 2,
        version_name_based_md5 = 3,
        version_random_number_based = 4,
        version_name_based_sha1 = 5
    };
    version_type version() const noexcept;
    // Swap function
    void swap(uuid& rhs) noexcept;
    uint8_t data[static_size()];
};
// standard operators
bool operator==(uuid const& lhs, uuid const& rhs) noexcept;
bool operator!=(uuid const& lhs, uuid const& rhs) noexcept;
bool operator<(uuid const& lhs, uuid const& rhs) noexcept;
bool operator>(uuid const& lhs, uuid const& rhs) noexcept;
bool operator<=(uuid const& lhs, uuid const& rhs) noexcept;
bool operator>=(uuid const& lhs, uuid const& rhs) noexcept;
void swap(uuid& lhs, uuid& rhs) noexcept;
std::size_t hash_value(uuid const& u) noexcept;
}} // namespace boost::uuids
Size
The size of a uuid (in bytes) can be obtained either by
calling the function boost::uuids::uuid::size() or by 
calling the static function boost::uuids::uuid::static_size(), 
both always return 16.
    boost::uuids::uuid u;
    assert(16 == u.size());
    assert(16 == boost::uuids::uuid::static_size());
Iteration
Both iterators and constant iterators are provided.
    boost::uuids::uuid u;
    for (boost::uuids::uuid::const_iterator it=u.begin(); it!=u.end(); ++it) {
        boost::uuids::uuid::value_type v = *it;
    }
    for (boost::uuids::uuid::iterator it=u.begin(); it!=u.end(); ++it) {
        *it = 0;
    }
Nil uuid
The function, boost::uuids::uuid::is_nil() returns true if and
only if the uuid is equal to {00000000-0000-0000-0000-000000000000}.
Variant
Three bits of a uuid determine the variant.
    boost::uuids::uuid u;
    boost::uuids::uuid::variant_type v = u.variant();
Version
Four bits of a uuid determine the variant, that is the mechanism
used to generate the uuid.
    boost::uuids::uuid u;
    boost::uuids::uuid::version_type v = u.version();
Swap
Both boost::uuids::uuid::swap() and boost::uuids::swap() 
are provided.
    boost::uuids::uuid u1, u2;
    u1.swap(u2);
    swap(u1, u2);
Operators
All of the standard numeric operators are defined for the uuid
class. These include:
    operator==
    operator!=
    operator<
    operator>
    operator<=
    operator>=
Hash Function
This function allows uuids to be used with 
boost::hash
boost::hash<boost::uuids::uuid> uuid_hasher;
std::size_t uuid_hash_value = uuid_hasher(boost::uuids::uuid());
boost/uuid/uuid_generators.hpp
Synopsis
This file includes all the uuid generators for convenience.
#include <boost/uuid/nil_generator.hpp>
#include <boost/uuid/string_generator.hpp>
#include <boost/uuid/name_generator.hpp>
#include <boost/uuid/random_generator.hpp>
boost/uuid/nil_generator.hpp
Synopsis
namespace boost {
namespace uuids {
struct nil_generator {
    typedef uuid result_type;
    
    uuid operator()() const;
};
uuid nil_uuid();
}} //namespace boost::uuids
Nil Generator
The boost::uuids::nil_generator class always generates a nil uuid.
boost::uuids::nil_generator gen;
boost::uuids::uuid u = gen();
assert(u.is_nil() == true);
// or for convenience
boost::uuids::uuid u = boost::uuids::nil_uuid();
assert(u.is_nil() == true);
boost/uuid/string_generator.hpp
Synopsis
namespace boost {
namespace uuids {
struct string_generator {
    typedef uuid result_type;
    template <typename ch, typename char_traits, typename alloc>
        uuid operator()(std::basic_string<ch, char_traits, alloc> const& s) const;
};
}} //namespace boost::uuids
String Generator
The boost::uuids::string_generator class generates a uuid from a string.
boost::uuids::string_generator gen;
boost::uuids::uuid u1 = gen("{01234567-89ab-cdef-0123-456789abcdef}");
boost::uuids::uuid u2 = gen(L"01234567-89ab-cdef-0123-456789abcdef");
boost::uuids::uuid u3 = gen(std::string("0123456789abcdef0123456789abcdef"));
boost::uuids::uuid u4 = gen(std::wstring(L"01234567-89ab-cdef-0123-456789abcdef"));
boost/uuid/name_generator.hpp
Synopsis
namespace boost {
namespace uuids {
class name_generator {
public:
    typedef uuid result_type;
    
    explicit name_generator(uuid const& namespace_uuid);
    uuid operator()(const char* name) const;
    uuid operator()(const wchar_t* name) const;
    tempate <typename ch, typename char_traits, typename alloc>
        uuid operator()(std::basic_string<ch, char_traits, alloc> const& name) const;
    uuid operator()(void const* buffer, std::size_t byte_count) const;
};
}} //namespace boost::uuids
Name Generator
The boost::uuids::name_generator class generates a name based uuid from a
namespace uuid and a name.
boost::uuids::uuid dns_namespace_uuid; // initialize to {6ba7b810-9dad-11d1-80b4-00c04fd430c8}
boost::uuids::name_generator gen(dns_namespace_uuid);
boost::uuids::uuid u = gen("boost.org");
boost/uuid/random_generator.hpp
Synopsis
namespace boost {
namespace uuids {
template <typename UniformRandomNumberGenerator>
class basic_random_generator {
public:
    typedef uuid result_type;
    
    basic_random_generator();
    explicit basic_random_generator(UniformRandomNumberGenerator& gen);
    explicit basic_random_generator(UniformRandomNumberGenerator* pGen);
    
    uuid operator()();
};
typedef basic_random_generator<mt19937> random_generator;
}} // namespace boost::uuids
Random Generator
The boost::uuids::basic_random_generator class generates a random number
based uuid from a random number generator (one that conforms to the 
UniformRandomNumberGenerator
concept).
//default construct the random number generator and seed it
boost::uuids::basic_random_generator<boost::mt19937> gen;
boost::uuids::uuid u = gen();
//for convenience boost::uuids::random_generator
//is equivalent to boost::uuids::basic_random_generator<boost::mt19937>
boost::uuids::random_generator gen;
boost::uuids::uuid u = gen();
//use an existing random number generator
//pass either a reference or a pointer to the random number generator
boost::mt19937 ran;
boost::uuids::basic_random_generator<boost::mt19937> gen(&ran);
boost::uuids::uuid u = gen();
boost/uuid/uuid_io.hpp
Synopsis
namespace boost {
namespace uuids {
template <typename ch, typename char_traits>
    std::basic_ostream<ch, char_traits>& operator<<(std::basic_ostream<ch, char_traits> &os, uuid const& u);
template <typename ch, typename char_traits>
    std::basic_istream<ch, char_traits>& operator>>(std::basic_istream<ch, char_traits> &is, uuid &u);
    
std::string to_string(uuid const& u);
std::wstring to_wstring(uuid const& u);
}} // namespace boost::uuids
Stream Operators
The standard input and output stream operators << and >>
are provided by including boost/uuid/uuid_io.hpp.
The string representation of a uuid is hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh 
where h is a hexidecimal digit.
boost::uuids::uuid u1; // initialize uuid
std::stringstream ss;
ss << u1;
boost::uuids::uuid u2;
ss >> u2;
assert(u1, u2);
One can also use boost::lexical_cast.
boost::uuids::uuid u1; // initialize uuid
std::string s = boost::lexical_cast<std::string>(u);
boost::uuids::uuid u2 = boost::lexical_cast<boost::uuids::uuid>(s);
assert(u1 == u2);
To String
The functions to_string and to_wstring are provided as a 
convenience to convert a uuid to a string.  They are also likely faster than
the stream operators or using boost::lexical_cast.
boost::uuids::uuid u; // initialize uuid
std::string s1 = to_string(u);
std::wstring s2 = to_wstring(u);
boost/uuid/uuid_serialize.hpp
Synopsis
namespace boost {
namespace uuids {
BOOST_CLASS_IMPLEMENTATION(boost::uuids::uuid, boost::serialization::primitive_type)
}} // namespace boost::uuids
Serialization
Serialization is accomplished with the 
Boost Serialization library.  A uuid is serialized as a 
primitive type, thus only the uuid value will be saved to/loaded from an archive.
Include boost/uuid/uuid_serialize.hpp to enable serialization for uuids.
Design notes
The document, 
http://www.itu.int/ITU-T/studygroups/com17/oid/X.667-E.pdf, was used to design
and implement the boost::uuids::uuid struct.
The boost::uuids::basic_random_generator class' default constructor 
seeds the random number generator with a SHA-1 hash of a number of different
values including std::time(0), std::clock(), uninitialized
data, value return from new unsigned int, etc..
Using Valgrind produces a number of false
positives with the default constructor of boost::uuids::basic_random_generator.  
One solution is to suppress the errors as described in
Valgrind's documentation.
Another solution is to use a different constructor of boost::uuids::basic_random_generator
and explicitly pass in a random number generator.
boost::mt19937 ran;
ran.seed(time(NULL)); // one should likely seed in a better way
boost::uuids::basic_random_generator<boost::mt19937> gen(&ran);
boost::uuids::uuid u = gen();
The boost::uuids::name_generator class uses the SHA-1 hash function to
compute the uuid.
All functions are re-entrant.  Classes are as thread-safe as an int.  That is an 
instance can not be shared between threads without proper synchronization.
History and Acknowledgements
A number of people on the boost.org 
mailing list provided useful comments and greatly helped to shape the library.
Revised  February 6, 2010
© Copyright Andy Tompkins, 2006
 Distributed under the Boost Software 
License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at 
www.boost.org/LICENSE_1_0.txt)
