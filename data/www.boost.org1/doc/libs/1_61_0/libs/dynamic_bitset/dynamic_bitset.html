<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
dynamic_bitset<Block, Allocator> - 1.61.0
  
    
  
  
  
  
  Boost
  C++ Libraries
  
  
  ...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.  Herb Sutter and Andrei
  Alexandrescu, C++
  Coding Standards
  
  
This is the documentation for an old version of Boost.
                Click here to view this page for the latest version.
dynamic_bitset<Block, Allocator>
Contents
Description
Synopsis
Definitions
Examples
Rationale
Header Files
Template Parameters
Concepts modeled
Type requirements
Public base classes
Nested type names
Public data members
Constructors
Destructor
Member functions
Non-member functions
Exception guarantees
Changes from previous version(s)
See also
Acknowledgements
Description
The dynamic_bitset class represents a set of bits. It
provides accesses to the value of individual bits via an
operator[] and provides all of the bitwise operators
that one can apply to builtin integers, such as
operator& and operator<<. The number
of bits in the set is specified at runtime via a parameter to the
constructor of the dynamic_bitset.
The dynamic_bitset class is nearly identical to the
std::bitset
class. The difference is that the size of the
dynamic_bitset (the number of bits) is specified at
run-time during the construction of a dynamic_bitset
object, whereas the size of a std::bitset is specified
at compile-time through an integer template parameter.
The main problem that dynamic_bitset is designed to
solve is that of representing a subset of a finite set. Each bit
represents whether an element of the finite set is in the subset
or not. As such the bitwise operations of
dynamic_bitset, such as operator& and
operator|, correspond to set operations, such as
intersection and union.
Synopsis
namespace boost {
template <typename Block, typename Allocator>
class dynamic_bitset
{
public:
    typedef Block block_type;
    typedef Allocator allocator_type;
    typedef implementation-defined size_type;
    static const int bits_per_block = implementation-defined;
    static const size_type npos = implementation-defined;
    class reference
    {
        void operator&(); // not defined
    public:
        // An automatically generated copy constructor.
        reference& operator=(bool value);
        reference& operator=(const reference& rhs);
        reference& operator|=(bool value);
        reference& operator&=(bool value);
        reference& operator^=(bool value);
        reference& operator-=(bool value);
        bool operator~() const;
        operator bool() const;
        reference& flip();
    };
    typedef bool const_reference;
    explicit dynamic_bitset(const Allocator& alloc = Allocator());
    explicit dynamic_bitset(size_type num_bits, unsigned long value = 0,
                            const Allocator& alloc = Allocator());
    template <typename CharT, typename Traits, typename Alloc>
    explicit dynamic_bitset(const std::basic_string<CharT, Traits, Alloc>& s,
        typename std::basic_string<CharT, Traits, Alloc>::size_type pos = 0,
        typename std::basic_string<CharT, Traits, Alloc>::size_type n = std::basic_string<CharT, Traits, Alloc>::npos,
        const Allocator& alloc = Allocator());
    template <typename BlockInputIterator>
    dynamic_bitset(BlockInputIterator first, BlockInputIterator last,
                   const Allocator& alloc = Allocator());
    dynamic_bitset(const dynamic_bitset& b);
    dynamic_bitset(dynamic_bitset&& b);
    void swap(dynamic_bitset& b);
    dynamic_bitset& operator=(const dynamic_bitset& b);
    dynamic_bitset& operator=(dynamic_bitset&& b);
    allocator_type get_allocator() const;
    void resize(size_type num_bits, bool value = false);
    void clear();
    void pop_back();
    void push_back(bool bit);
    void append(Block block);
    template <typename BlockInputIterator>
    void append(BlockInputIterator first, BlockInputIterator last);
    dynamic_bitset& operator&=(const dynamic_bitset& b);
    dynamic_bitset& operator|=(const dynamic_bitset& b);
    dynamic_bitset& operator^=(const dynamic_bitset& b);
    dynamic_bitset& operator-=(const dynamic_bitset& b);
    dynamic_bitset& operator<<=(size_type n);
    dynamic_bitset& operator>>=(size_type n);
    dynamic_bitset operator<<(size_type n) const;
    dynamic_bitset operator>>(size_type n) const;
    dynamic_bitset& set(size_type n, bool val = true);
    dynamic_bitset& set();
    dynamic_bitset& reset(size_type n);
    dynamic_bitset& reset();
    dynamic_bitset& flip(size_type n);
    dynamic_bitset& flip();
    bool test(size_type n) const;
    bool test_set(size_type n, bool val = true);
    bool all() const;
    bool any() const;
    bool none() const;
    dynamic_bitset operator~() const;
    size_type count() const noexcept;
    reference operator[](size_type pos);
    bool operator[](size_type pos) const;
    unsigned long to_ulong() const;
    size_type size() const noexcept;
    size_type num_blocks() const noexcept;
    size_type max_size() const noexcept;
    bool empty() const noexcept;
    bool is_subset_of(const dynamic_bitset& a) const;
    bool is_proper_subset_of(const dynamic_bitset& a) const;
    bool intersects(const dynamic_bitset& a) const;
    size_type find_first() const;
    size_type find_next(size_type pos) const;
};
template <typename B, typename A>
bool operator==(const dynamic_bitset<B, A>& a, const dynamic_bitset<B, A>& b);
template <typename Block, typename Allocator>
bool operator!=(const dynamic_bitset<Block, Allocator>& a, const dynamic_bitset<Block, Allocator>& b);
template <typename B, typename A>
bool operator<(const dynamic_bitset<B, A>& a, const dynamic_bitset<B, A>& b);
template <typename Block, typename Allocator>
bool operator<=(const dynamic_bitset<Block, Allocator>& a, const dynamic_bitset<Block, Allocator>& b);
template <typename Block, typename Allocator>
bool operator>(const dynamic_bitset<Block, Allocator>& a, const dynamic_bitset<Block, Allocator>& b);
template <typename Block, typename Allocator>
bool operator>=(const dynamic_bitset<Block, Allocator>& a, const dynamic_bitset<Block, Allocator>& b);
template <typename Block, typename Allocator>
dynamic_bitset<Block, Allocator>
operator&(const dynamic_bitset<Block, Allocator>& b1, const dynamic_bitset<Block, Allocator>& b2);
template <typename Block, typename Allocator>
dynamic_bitset<Block, Allocator>
operator|(const dynamic_bitset<Block, Allocator>& b1, const dynamic_bitset<Block, Allocator>& b2);
template <typename Block, typename Allocator>
dynamic_bitset<Block, Allocator>
operator^(const dynamic_bitset<Block, Allocator>& b1, const dynamic_bitset<Block, Allocator>& b2);
template <typename Block, typename Allocator>
dynamic_bitset<Block, Allocator>
operator-(const dynamic_bitset<Block, Allocator>& b1, const dynamic_bitset<Block, Allocator>& b2);
template <typename Block, typename Allocator, typename CharT, typename Alloc>
void to_string(const dynamic_bitset<Block, Allocator>& b,
          std::basic_string<CharT, Alloc>& s);
template <typename Block, typename Allocator, typename BlockOutputIterator>
void to_block_range(const dynamic_bitset<Block, Allocator>& b,
                    BlockOutputIterator result);
template <typename CharT, typename Traits, typename Block, typename Allocator>
std::basic_ostream<CharT, Traits>&
operator<<(std::basic_ostream<CharT, Traits>& os, const dynamic_bitset<Block, Allocator>& b);
template <typename CharT, typename Traits, typename Block, typename Allocator>
std::basic_istream<CharT, Traits>&
operator>>(std::basic_istream<CharT, Traits>& is, dynamic_bitset<Block, Allocator>& b);
} // namespace boost
Definitions
Each bit represents either the Boolean value true or false (1
or 0). To set a bit is to assign it 1. To clear or
reset a bit is to assign it 0. To flip a bit is to
change the value to 1 if it was 0 and to 0 if it was 1. Each bit
has a non-negative position. A bitset x contains
x.size() bits, with each bit assigned a unique position
in the range [0,x.size()). The bit at position 0 is
called the least significant bit and the bit at position
size() - 1 is the most significant bit. When
converting an instance of dynamic_bitset to or from an
unsigned long n, the bit at position i of the
bitset has the same value as (n >> i) & 1.
Examples
Example 1 (setting
and reading some bits)
Example 2 (creating
some bitsets from integers)
Example 3 (performing
input/output and some bitwise operations).
Rationale
dynamic_bitset is not a Container and
does not provide iterators for the following reason:
A container with a proxy reference type can not
fulfill the container requirements as specified in the C++
standard (unless one resorts to strange iterator semantics).
std::vector<bool> has a proxy reference
type and does not fulfill the container requirements and as a
result has caused many problems. One common problem is when
people try to use iterators from std::vector<bool>
with a Standard algorithm such as std::search. The
std::search requirements say that the iterator must be a
Forward
Iterator, but the std::vector<bool>::iterator
does not meet this requirement because of the proxy reference.
Depending on the implementation, they may or not be a compile
error or even a run-time error due to this misuse. For further
discussion of the problem see Effective STL by Scott
Meyers). So dynamic_bitset tries to avoid these problems
by not pretending to be a container.
Some people prefer the name "toggle" to "flip". The name
"flip" was chosen because that is the name used in std::bitset.
In fact, most of the function names for dynamic_bitset
were chosen for this reason.
dynamic_bitset does not throw exceptions when a
precondition is violated (as is done in std::bitset).
Instead assert is used. See the guidelines for Error and Exception Handling
for the explanation.
Header Files
The class dynamic_bitset is defined in the header boost/dynamic_bitset.hpp.
Also, there is a forward declaration for dynamic_bitset
in the header boost/dynamic_bitset_fwd.hpp.
Template parameters
Parameter
Description
Default
Block
The integer type in which the bits are stored.
unsigned long
Allocator
The allocator type used for all internal memory management.
std::allocator<Block>
Concepts Modeled
Assignable, Default
Constructible, Equality
Comparable, LessThan
Comparable.
Type requirements
Block is an unsigned integer type. Allocator
satisfies the Standard requirements for an allocator.
Public base classes
None.
Nested type names
dynamic_bitset::reference
A proxy class that acts as a reference to a single bit. It
contains an assignment operator, a conversion to bool,
an operator~, and a member function flip. It
exists only as a helper class for dynamic_bitset's
operator[]. The following table describes the valid
operations on the reference type. Assume that b
is an instance of dynamic_bitset, i, j are of
size_type and in the range [0,b.size()). Also,
note that when we write b[i] we mean an object of type
reference that was initialized from b[i]. The
variable x is a bool.
Expression
Semantics
x = b[i]
Assign the ith bit of b to x.
(bool)b[i]
Return the ith bit of b.
b[i] = x
Set the ith bit of b to the value of x and
return b[i].
b[i] |= x
Or the ith bit of b with the value of x and
return b[i].
b[i] &= x
And the ith bit of b with the value of x
and return b[i].
b[i] ^= x
Exclusive-Or the ith bit of b with the value of
x and return b[i].
b[i] -= x
If x==true, clear the ith bit of b. Returns
b[i].
b[i] = b[j]
Set the ith bit of b to the value of the jth bit of
b and return b[i].
b[i] |= b[j]
Or the ith bit of b with the jth bit of b
and return b[i].
b[i] &= b[j]
And the ith bit of b with the jth bit of b and return b[i].
b[i] ^= b[j]
Exclusive-Or the ith bit of b with the jth bit of b and return b[i].
b[i] -= b[j]
If the jth bit of b is set, clear the ith bit of b. Returns b[i].
x = ~b[i]
Assign the opposite of the ith bit of b to x.
(bool)~b[i]
Return the opposite of the ith bit of b.
b[i].flip()
Flip the ith bit of b and return b[i].
dynamic_bitset::const_reference
The type bool.
dynamic_bitset::size_type
The unsigned integer type for representing the size of the bit set.
dynamic_bitset::block_type
The same type as Block.
dynamic_bitset::allocator_type;
The same type as Allocator.
Public data members
dynamic_bitset::bits_per_block
The number of bits the type Block uses to represent values,
excluding any padding bits. Numerically equal
to std::numeric_limits<Block>::digits.
dynamic_bitset::npos
The maximum value of size_type.
Constructors
dynamic_bitset(const Allocator& alloc = Allocator())
Effects: Constructs a bitset of size zero. A copy of the
alloc object will be used in subsequent bitset
operations such as resize to allocate memory.
 Postconditions: this->size() == 0.
 Throws: An allocation error if memory is exhausted
(std::bad_alloc if
Allocator=std::allocator).
 (Required by Default
Constructible.)
dynamic_bitset(size_type num_bits,
               unsigned long value = 0,
               const Allocator& alloc = Allocator())
Effects: Constructs a bitset from an integer. The first
M bits are initialized to the corresponding bits in
value and all other bits, if any, to zero (where M =
min(num_bits, std::numeric_limits<unsigned long>::digits)). A copy of
the alloc object will be used in subsequent bitset
operations such as resize to allocate memory. Note that, e.g., the
following
dynamic_bitset b<>( 16, 7 );
will match the constructor from an iterator range (not this
one), but the underlying implementation will still "do the right thing" and
construct a bitset of 16 bits, from the value 7.
Postconditions:
this->size() == num_bits
For all i in the range [0,M),
(*this)[i] == (value >> i) & 1.
For all i in the range [M,num_bits),
(*this)[i] == false.
Throws: An allocation error if memory is exhausted
(std::bad_alloc if
Allocator=std::allocator).
dynamic_bitset(const dynamic_bitset& x)
Effects: Constructs a bitset that is a copy of the bitset
x. The allocator for this bitset is a copy of the
allocator in x. 
 Postconditions: For all i in the range
[0,x.size()), (*this)[i] == x[i].
 Throws: An allocation error if memory is exhausted
(std::bad_alloc if
Allocator=std::allocator).
 (Required by Assignable.)
dynamic_bitset(dynamic_bitset&& x)
Effects: Constructs a bitset that is the same as the bitset
x, while using the resources from x. The allocator
for this bitset is moved from the allocator in x. 
 Postconditions: For all i in the range
[0,x.size()), (*this)[i] == x[i].
 Throws: An allocation error if memory is exhausted
(std::bad_alloc if
Allocator=std::allocator).
template <typename BlockInputIterator>
explicit
dynamic_bitset(BlockInputIterator first, BlockInputIterator last,
               const Allocator& alloc = Allocator());
Effects:
If this constructor is called with a type BlockInputIterator which
is actually an integral type, the library behaves as if the constructor
from unsigned long were called, with arguments
static_cast<size_type>(first), last and alloc, in that order.
Example:
// b is constructed as if by calling the constructor
//
//   dynamic_bitset(size_type num_bits,
//                  unsigned long value = 0,
//                  const Allocator& alloc = Allocator())
//
// with arguments
//
//   static_cast<dynamic_bitset<unsigned short>::size_type>(8),
//   7,
//   Allocator()
//
dynamic_bitset<unsigned short> b(8, 7);
Note:
At the time of writing (October 2008) this is aligned with the
proposed resolution for library
    issue 438. That is a post C++03
change, and is currently in the working paper for
C++0x. Informally speaking, the critical changes with
respect to C++03 are the drop of a static_cast
on the second argument, and more leeway as to when the
templated constructor should have the same effect as the (size,
value) one: only when InputIterator is an integral
type, in C++03; when it is either an integral type or
any other type that the implementation might detect as
impossible to be an input iterator, with the proposed
resolution. For the purposes of dynamic_bitset we limit
ourselves to the first of these two changes.
Otherwise (i.e. if the template argument is not an
integral type), constructsunder the condition in the
requires clausea bitset based on a range of
blocks. Let *first be block number 0, *++first
block number 1, etc. Block number b is used to
initialize the bits of the dynamic_bitset in the position range
[b*bits_per_block, (b+1)*bits_per_block). For each
block number b with value bval, the bit
(bval >> i) & 1 corresponds to the bit at
position (b * bits_per_block + i) in the bitset (where
i goes through the range [0, bits_per_block)).
Requires: BlockInputIterator must be either an
integral type or a model of Input
    Iterator whose value_type is the same type as
Block.
 Throws: An allocation error if
memory is exhausted (std::bad_alloc if
Allocator=std::allocator).
template<typename Char, typename Traits, typename Alloc>
explicit
dynamic_bitset(const std::basic_string<Char,Traits,Alloc>& s,
               typename std::basic_string<CharT, Traits, Alloc>::size_type pos = 0,
               typename std::basic_string<CharT, Traits, Alloc>::size_type n = std::basic_string<Char,Traits,Alloc>::npos,
               const Allocator& alloc = Allocator())
Precondition: pos <= s.size() and the
characters used to initialize the bits must be 0 or
1.
 Effects: Constructs a bitset from a string of 0's and
1's. The first M bits are initialized to the
corresponding characters in s, where M =
min(s.size() - pos, n). Note that the highest
character position in s, not the lowest, corresponds to
the least significant bit. That is, character position pos +
M - 1 - i corresponds to bit i. So, for example,
dynamic_bitset(string("1101")) is the same as
dynamic_bitset(13ul).
 Throws: an allocation error if memory is exhausted
(std::bad_alloc if Allocator=std::allocator).
Destructor
~dynamic_bitset()
Effects: Releases the memory associated with this bitset
and destroys the bitset object itself.
 Throws: nothing.
Member Functions
void swap(dynamic_bitset& b);
Effects: The contents of this bitset and bitset b
are exchanged.
Postconditions: This bitset is equal to the original
b, and b is equal to the previous version of
this bitset.
Throws: nothing.
dynamic_bitset& operator=(const dynamic_bitset& x)
Effects: This bitset becomes a copy of the bitset
x.
 Postconditions: For all i in the range
[0,x.size()), (*this)[i] == x[i].
 Returns: *this.
 Throws: nothing. 
(Required by Assignable.)
dynamic_bitset& operator=(dynamic_bitset&& x)
Effects: This bitset becomes the same as the bitset
x, while using the resources from x.
 Postconditions: For all i in the range
[0,x.size()), (*this)[i] == x[i].
 Returns: *this.
 Throws: An allocation error if memory is exhausted
(std::bad_alloc if Allocator=std::allocator).
allocator_type get_allocator() const;
 Returns: A copy of the allocator object used to construct *this.
void resize(size_type num_bits, bool value = false);
Effects: Changes the number of bits of the bitset to
num_bits. If num_bits > size() then the bits
in the range [0,size()) remain the same, and the bits in
[size(),num_bits) are all set to value. If
num_bits < size() then the bits in the range
[0,num_bits) stay the same (and the remaining bits are
discarded).
 Postconditions: this->size() == num_bits.
 Throws: An allocation error if memory is exhausted
(std::bad_alloc if
Allocator=std::allocator).
void clear()
Effects: The size of the bitset becomes zero.
 Throws: nothing.
void pop_back();
Precondition: !this->empty().
Effects: Decreases the size of the bitset by one.
 Throws: nothing.
 
void push_back(bool value);
Effects: Increases the size of the bitset by one, and sets
the value of the new most-significant bit to value.
 Throws: An allocation error if memory is exhausted
(std::bad_alloc if
Allocator=std::allocator).
void append(Block value);
Effects: Appends the bits in value to the bitset
(appends to the most-significant end). This increases the size of
the bitset by bits_per_block. Let s be the old
size of the bitset, then for i in the range
[0,bits_per_block), the bit at position (s + i)
is set to ((value >> i) & 1).
 Throws: An allocation error if memory is exhausted
(std::bad_alloc if
Allocator=std::allocator).
template <typename BlockInputIterator>
void append(BlockInputIterator first, BlockInputIterator last);
Effects: This function provides the same end result as the
following code, but is typically more efficient.
for (; first != last; ++first)
  append(*first);
Requires: The BlockInputIterator type must be a
model of Input
Iterator and the value_type must be the same type as
Block.
 Throws: An allocation error if memory is exhausted
(std::bad_alloc if
Allocator=std::allocator).
dynamic_bitset& operator&=(const dynamic_bitset& rhs)
Requires: this->size() == rhs.size().
 Effects: Bitwise-AND all the bits in rhs with
the bits in this bitset. This is equivalent to:
for (size_type i = 0; i != this->size(); ++i)
  (*this)[i] = (*this)[i] & rhs[i];
Returns: *this.
 Throws: nothing.
dynamic_bitset& operator|=(const dynamic_bitset& rhs)
Requires: this->size() == rhs.size().
 Effects: Bitwise-OR's all the bits in rhs with
the bits in this bitset. This is equivalent to:
for (size_type i = 0; i != this->size(); ++i)
  (*this)[i] = (*this)[i] | rhs[i];
Returns: *this.
 Throws: nothing.
dynamic_bitset& operator^=(const dynamic_bitset& rhs)
Requires: this->size() == rhs.size().
 Effects: Bitwise-XOR's all the bits in rhs with
the bits in this bitset. This is equivalent to:
for (size_type i = 0; i != this->size(); ++i)
  (*this)[i] = (*this)[i] ^ rhs[i];
Returns: *this.
 Throws: nothing.
dynamic_bitset& operator-=(const dynamic_bitset& rhs)
Requires: this->size() == rhs.size().
 Effects: Computes the set difference of this bitset and
the rhs bitset. This is equivalent to:
for (size_type i = 0; i != this->size(); ++i)
  (*this)[i] = (*this)[i] && !rhs[i];
Returns: *this.
 Throws: nothing.
dynamic_bitset& operator<<=(size_type n)
Effects: Shifts the bits in this bitset to the left by
n bits. For each bit in the bitset, the bit at position
pos takes on the previous value of the bit at position pos -
n, or zero if no such bit exists.
 Returns: *this.
 Throws: nothing.
dynamic_bitset& operator>>=(size_type n)
Effects: Shifts the bits in this bitset to the right by
n bits. For each bit in the bitset, the bit at position
pos takes on the previous value of bit pos + n,
or zero if no such bit exists.
 Returns: *this.
 Throws: nothing.
dynamic_bitset operator<<(size_type n) const
Returns: a copy of *this shifted to the left by
n bits. For each bit in the returned bitset, the bit at
position pos takes on the value of the bit at position pos -
n of this bitset, or zero if no such bit exists.
 Throws: An allocation error if memory is exhausted
(std::bad_alloc if Allocator=std::allocator).
dynamic_bitset operator>>(size_type n) const
Returns: a copy of *this shifted to the right by
n bits. For each bit in the returned bitset, the bit at
position pos takes on the value of the bit at position pos +
n of this bitset, or zero if no such bit exists.
 Throws: An allocation error if memory is exhausted
(std::bad_alloc if Allocator=std::allocator).
dynamic_bitset& set()
Effects: Sets every bit in this bitset to 1.
Returns: *this
Throws: nothing.
dynamic_bitset& flip()
Effects: Flips the value of every bit in this bitset.
Returns: *this
Throws: nothing.
dynamic_bitset operator~() const
Returns: a copy of *this with all of its bits
flipped.
Throws: An allocation error if memory is exhausted
(std::bad_alloc if Allocator=std::allocator).
dynamic_bitset& reset()
Effects: Clears every bit in this bitset.
Returns: *this
Throws: nothing.
dynamic_bitset& set(size_type n, bool val = true)
Precondition: n < this->size().
 Effects: Sets bit n if val is
true, and clears bit n if val is
false. 
 Returns: *this
dynamic_bitset& reset(size_type n)
Precondition: n < this->size().
Effects: Clears bit n.
Returns: *this
dynamic_bitset& flip(size_type n)
Precondition: n < this->size().
Effects: Flips bit n.
Returns: *this
size_type size() const
Returns: the number of bits in this bitset.
Throws: nothing.
size_type num_blocks() const
Returns: the number of blocks in this bitset.
Throws: nothing.
size_type max_size() const;
Returns: the maximum size of a dynamic_bitset
object having the same type as *this. Note that if
any dynamic_bitset operation causes size() to
exceed max_size() then the behavior is undefined.
[The semantics of this function could change slightly
when lib issue 197 will be closed]
bool empty() const;
Returns: true if this->size() == 0, false
otherwise. Note: not to be confused with none(), that has
different semantics.
size_type count() const
Returns: the number of bits in this bitset that are
set.
Throws: nothing.
bool all() const
Returns: true if all bits in this bitset are set or
if size() == 0, and otherwise returns false.
Throws: nothing.
bool any() const
Returns: true if any bits in this bitset are set,
and otherwise returns false.
Throws: nothing.
bool none() const
Returns: true if no bits are set, and otherwise
returns false.
Throws: nothing.
bool test(size_type n) const
Precondition: n < this->size().
 Returns: true if bit n is set and
false is bit n is 0.
bool test_set(size_type n, bool val = true)
Precondition: n < this->size().
 Effects: Sets bit n if val is
true, and clears bit n if val is
false. 
 Returns: true if the previous state of bit
n was set and false is bit n is 0.
reference operator[](size_type n)
Precondition: n < this->size().
 Returns: a reference to bit n. Note
that reference is a proxy class with an assignment
operator and a conversion to bool, which allows you to
use operator[] for assignment. That is, you can write
both x = b[n] and b[n] = x. However, in many
other respects the proxy is not the same as the true reference
type bool&.
bool operator[](size_type n) const
Precondition: n < this->size().
Returns: The same as test(n).
unsigned long to_ulong() const
Returns: The numeric value corresponding to the bits in *this.
Throws: std::overflow_error if that value is too large to
be represented in an unsigned long, i.e. if *this has
any non-zero bit at a position >=
std::numeric_limits<unsigned long>::digits.
bool is_subset_of(const dynamic_bitset& a) const
Requires: this->size() == a.size()
Returns: true if this bitset is a subset of bitset
a. That is, it returns true if, for every bit that is
set in this bitset, the corresponding bit in bitset a is
also set. Otherwise this function returns false.
Throws: nothing.
bool is_proper_subset_of(const dynamic_bitset& a) const
Requires: this->size() == a.size()
Returns: true if this bitset is a proper subset of bitset
a. That is, it returns true if, for every bit that is
set in this bitset, the corresponding bit in bitset a is
also set and if this->count() < a.count().
Otherwise this function returns false.
Throws: nothing.
bool intersects(const dynamic_bitset& a) const
Requires: this->size() == a.size()
Returns: true if this bitset and a intersect.
That is, it returns true if, there is a bit which is set in this
bitset, such that the corresponding bit in bitset a is
also set. Otherwise this function returns false.
Throws: nothing.
size_type find_first() const;
Returns: the lowest index i such as bit i
is set, or npos if *this has no on bits.
size_type find_next(size_type pos) const;
Returns: the lowest index i greater than
pos such as bit i is set, or npos if
no such index exists.
bool operator==(const dynamic_bitset& rhs) const
Returns: true if this->size() ==
rhs.size() and if for all i in the range
[0,rhs.size()), (*this)[i] == rhs[i]. Otherwise
returns false.
 Throws: nothing.
 (Required by Equality
Comparable.)
bool operator!=(const dynamic_bitset& rhs) const
Returns: !((*this) == rhs)
Throws: nothing.
(Required by Equality
Comparable.)
bool operator<(const dynamic_bitset& rhs) const
Returns: true if this bitset is lexicographically
less than rhs, and returns false otherwise.
(See the description of lexicographical_compare
for a definition of lexicographic ordering). 
Throws: nothing.
(Required by Less Than
Comparable.)
bool operator>(const dynamic_bitset& rhs) const
Returns: !((*this) < rhs || (*this) ==
rhs)
Throws: nothing.
(Required by Less Than
Comparable.)
bool operator<=(const dynamic_bitset& rhs) const
Returns: (*this) < rhs || (*this) == rhs
Throws: nothing.
(Required by Less Than
Comparable.)
bool operator>=(const dynamic_bitset& rhs) const
Returns: (*this) > rhs || (*this) == rhs
Throws: nothing.
(Required by Less Than
Comparable.)
Non-Member Functions
dynamic_bitset operator&(const dynamic_bitset& a, const dynamic_bitset& b)
Requires: a.size() == b.size()
Returns: A new bitset that is the bitwise-AND of the
bitsets a and b.
Throws: An allocation error if memory is exhausted
(std::bad_alloc if Allocator=std::allocator).
dynamic_bitset operator|(const dynamic_bitset& a, const dynamic_bitset& b)
Requires: a.size() == b.size()
Returns: A new bitset that is the bitwise-OR of the
bitsets a and b.
Throws: An allocation error if memory is exhausted
(std::bad_alloc if Allocator=std::allocator).
dynamic_bitset operator^(const dynamic_bitset& a, const dynamic_bitset& b)
Requires: a.size() == b.size()
Returns: A new bitset that is the bitwise-XOR of the
bitsets a and b.
Throws: An allocation error if memory is exhausted
(std::bad_alloc if Allocator=std::allocator).
dynamic_bitset operator-(const dynamic_bitset& a, const dynamic_bitset& b)
Requires: a.size() == b.size()
Returns: A new bitset that is the set difference of the
bitsets a and b.
Throws: An allocation error if memory is exhausted
(std::bad_alloc if Allocator=std::allocator).
template <typename CharT, typename Alloc>
void to_string(const dynamic_bitset<Block, Allocator>& b,
               std::basic_string<Char,Traits,Alloc>& s)
Effects: Copies a representation of b into the
string s. A character in the string is '1' if
the corresponding bit is set, and '0' if it is not.
Character position i in the string corresponds to bit
position b.size() - 1 - i. 
 Throws: If memory is exhausted, the string will throw an
allocation error.
 Rationale: This function is not a member function taking
zero arguments and returning a string for a couple reasons.
First, this version can be slighly more efficient because the
string is not copied (due to being passed by value). Second, as a
member function, to allow for flexibility with regards to the
template parameters of basic_string, the member function
would require explicit template parameters. Few C++ programmers
are familiar with explicit template parameters, and some C++
compilers do not handle them properly.
template <typename Block, typename Alloc, typename BlockOutputIterator>
void to_block_range(const dynamic_bitset<Block, Alloc>& b, BlockOutputIterator result)
Effects: Writes the bits of the bitset into the iterator
result a block at a time. The first block written
represents the bits in the position range
[0,bits_per_block) in the bitset, the second block
written the bits in the range
[bits_pre_block,2*bits_per_block), and so on. For each
block bval written, the bit (bval >> i) &
1 corresponds to the bit at position (b * bits_per_block
+ i) in the bitset.
 Requires: The type BlockOutputIterator must be a
model of Output
Iterator and its value_type must be the same type as
Block. Further, the size of the output range must be
greater or equal b.num_blocks().
template <typename BlockIterator, typename Block, typename Alloc>
void from_block_range(BlockIterator first,
    BlockIterator last, const dynamic_bitset<Block, Alloc>& b)
Effects: Reads blocks from the iterator range into the
bitset. 
 Requires: The type BlockIterator must be a model
of Input
Iterator and its value_type must be the same type as
Block. The size of the iterator range must be less or
equal to b.num_blocks().
template <typename Char, typename Traits, typename Block, typename Alloc>
basic_ostream<Char, Traits>&
operator<<(basic_ostream<Char, Traits>& os, const dynamic_bitset<Block, Alloc>& b)
Effects: Inserts a textual representation of b into the stream
os (highest bit first). Informally, the output is the same as doing
std::basic_string<Char, Traits> s;
boost::to_string(x, s):
os << s;
except that the stream inserter takes into accout the locale imbued into
os, which boost::to_string() can't do. Here is a more
precise specification, given in terms of "as if" rule: first, for each
valid position i into the bitset b let's put:
 character_of(b[i)]) = b[i]? os.widen('1') : os.widen('0');
Let also s be a std::basic_string<Char, Traits>
object, having length b.size() and such as, for each i
in [0, b.size()),
 s[i] is character_of(b[i])
Then, the output, the effects on os and the exception behavior
is the same as outputting the object s to os (same
width, same exception mask, same padding, same setstate() logic)
Returns: os 
Throws: std::ios_base::failure if there is a
problem writing to the stream.
template <typename Char, typename Traits, typename Block, typename Alloc>
std::basic_istream<Char,Traits>&
operator>>(std::basic_istream<Char,Traits>& is, dynamic_bitset<Block, Alloc>& b)
Effects: Extracts a dynamic_bitset from an input stream.
 Definitions:
 Let Tr be the traits_type of is. Then:
 
 
 A (non-eof) character c extracted from is
 is a bitset digit if and only if either Tr::eq(c, is.widen('0')) or
 Tr::eq(c, is.widen('1')) return true.
 
 If c is a bitset digit, it's corresponding bit value is 0 if
 Tr::eq(c, is.widen('0')) is true, 1 otherwise.
 
 
The function begins by constructing a sentry object k as if k
were constructed by
 typename std::basic_istream<Char, Traits>::sentry k(is).
If bool(k) is true, it calls b.clear()
then attempts to extract characters from is. For each character c
that is a bitset digit the corresponding bit value is
appended to the less significant end of b (appending may throw).
If is.width() is greater than zero and smaller than b.max_size()
then the maximum number n of bits appended is is.width();
otherwise n = b.max_size().
Unless the extractor is exited via an exception, characters are extracted (and
corresponding bits appended) until any of the following occurs:
 n bits are stored into the bitset;
 end-of-file, or an error, occurs on the input sequence;
 the next available input character isn't a bitset digit
 If no exception caused the function to exit then is.width(0) is
     called, regardless of how many characters were actually extracted. The
     sentry object k is destroyed.
If the function extracts no characters[???], it calls is.setstate(std::ios::failbit),
     which may throw std::ios_base::failure.
------
Throws: An allocation error if memory is exhausted
(std::bad_alloc if Allocator=std::allocator).
A std::ios_base::failure if there is a problem reading
from the stream.
Exception guarantees
All of dynamic_bitset functions offer at least the basic
exception guarantee.
Changes from previous version(s)
Changes in Boost 1.56.0
Support for C++11 move constructors.
Warning fixes on MSVC 2013.
Support for C++11 minimal allocators.
Add noexcept specifications.
Changes in Boost 1.37.0
The constructor from a block range implements a "do the right thing"
behavior, a la standard sequences.
Changes from Boost 1.31.0
The stream extractor has completely different semantics: as natural
for a dynamic structure, it now expands the bitset as needed during
extraction. The new behaviour mimics that of the basic_string
extractor but there are some differences the user should be aware of;
so, please, check the documentation. (One
difference concerns the case where stream.width() >
    bitset.max_size() > 0. In that circumstance the
extractor of dynamic_bitset never attempts to extract more
than max_size() characters, whereas the extractor of
basic_string goes on and, on conforming implementations,
eventually throws a length_error exception. Note: That's what
the standard mandates -see especially library
    issue 83- but not all implementations conform)
The stream extractor is now also "exception-aware" in the sense that
it works correctly when setting exception masks on the stream.
Several member functions (empty(), find_first()
, find_next(), get_allocator(), intersects()
, max_size() )
have been added.
The constructor from basic_string has a new parameter that was totally
forgotten before.
Technicalities and minor changes
The class reference has been reimplemented so that
dynamic_bitset's references behave more like references to standard
container elements. In particular it is now guaranteed that they
cannot be invalidated from a standard library swap() function
applied to their corresponding dynamic_bitsets.
General improvements
Several optimizations to member and non-member functions and to the
nested class reference.
See also
std::bitset,
std::vector,
Acknowledgements
We would like to thank the Boost community for putting in the
time to review and accept this library. This library is much
better than it ever would have been due to all the suggestions
from Boost members. We especially thank Matt Marcus for taking on
the task of review manager. Also, a special thanks goes to
James Kanze for his invaluable help with the internationalization
issues.
  Copyright  2001
Jeremy
Siek, Indiana University (jsiek@osl.iu.edu)
 Chuck Allison, Senior Editor,
C/C++ Users Journal (cda@freshsources.com)
  
Copyright  2003-2004, 2008 Gennaro Prota
    (name.surname yahoo.com)
Copyright  2014
Ahmed Charles (acharles@outlook.com)
Copyright  2014
Glen Fernandes (glenfe@live.com)
    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt
    or copy at 
http://www.boost.org/LICENSE_1_0.txt)
